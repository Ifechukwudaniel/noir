Initial SSA:
acir(inline) fn main f0 {
  b0(v0: [Field; 2], v2: [u1; 2], v3: [u64; 2]):
    v1 = allocate
    store v0 at v1
    inc_rc v0
    inc_rc v2
    inc_rc v3
    jmp b1(u32 0)
  b1(v4: u32):
    v7 = lt v4, u32 2
    jmpif v7 then: b2, else: b3
  b2():
    v9 = array_get v2, index v4
    jmpif v9 then: b4, else: b5
  b4():
    v10 = load v1
    v11 = array_get v3, index v4
    v12 = cast v4 as Field
    v13 = cast v11 as u32
    v14 = array_set v10, index v13, value v12
    v15 = add v13, u32 1
    store v14 at v1
    jmp b5()
  b5():
    v16 = add v4, u32 1
    jmp b1(v16)
  b3():
    v17 = load v1
    dec_rc v0
    dec_rc v2
    dec_rc v3
    return v17
}

After Defunctionalization:
acir(inline) fn main f0 {
  b0(v0: [Field; 2], v2: [u1; 2], v3: [u64; 2]):
    v1 = allocate
    store v0 at v1
    inc_rc v0
    inc_rc v2
    inc_rc v3
    jmp b1(u32 0)
  b1(v4: u32):
    v7 = lt v4, u32 2
    jmpif v7 then: b2, else: b3
  b2():
    v9 = array_get v2, index v4
    jmpif v9 then: b4, else: b5
  b4():
    v10 = load v1
    v11 = array_get v3, index v4
    v12 = cast v4 as Field
    v13 = cast v11 as u32
    v14 = array_set v10, index v13, value v12
    v15 = add v13, u32 1
    store v14 at v1
    jmp b5()
  b5():
    v16 = add v4, u32 1
    jmp b1(v16)
  b3():
    v17 = load v1
    dec_rc v0
    dec_rc v2
    dec_rc v3
    return v17
}

After Removing Paired rc_inc & rc_decs:
acir(inline) fn main f0 {
  b0(v0: [Field; 2], v2: [u1; 2], v3: [u64; 2]):
    v1 = allocate
    store v0 at v1
    inc_rc v0
    jmp b1(u32 0)
  b1(v4: u32):
    v7 = lt v4, u32 2
    jmpif v7 then: b2, else: b3
  b2():
    v9 = array_get v2, index v4
    jmpif v9 then: b4, else: b5
  b4():
    v10 = load v1
    v11 = array_get v3, index v4
    v12 = cast v4 as Field
    v13 = cast v11 as u32
    v14 = array_set v10, index v13, value v12
    v15 = add v13, u32 1
    store v14 at v1
    jmp b5()
  b5():
    v16 = add v4, u32 1
    jmp b1(v16)
  b3():
    v17 = load v1
    dec_rc v0
    return v17
}

After Runtime Separation:
acir(inline) fn main f0 {
  b0(v0: [Field; 2], v2: [u1; 2], v3: [u64; 2]):
    v1 = allocate
    store v0 at v1
    inc_rc v0
    jmp b1(u32 0)
  b1(v4: u32):
    v7 = lt v4, u32 2
    jmpif v7 then: b2, else: b3
  b2():
    v9 = array_get v2, index v4
    jmpif v9 then: b4, else: b5
  b4():
    v10 = load v1
    v11 = array_get v3, index v4
    v12 = cast v4 as Field
    v13 = cast v11 as u32
    v14 = array_set v10, index v13, value v12
    v15 = add v13, u32 1
    store v14 at v1
    jmp b5()
  b5():
    v16 = add v4, u32 1
    jmp b1(v16)
  b3():
    v17 = load v1
    dec_rc v0
    return v17
}

After Resolving IsUnconstrained:
acir(inline) fn main f0 {
  b0(v0: [Field; 2], v2: [u1; 2], v3: [u64; 2]):
    v1 = allocate
    store v0 at v1
    inc_rc v0
    jmp b1(u32 0)
  b1(v4: u32):
    v7 = lt v4, u32 2
    jmpif v7 then: b2, else: b3
  b2():
    v9 = array_get v2, index v4
    jmpif v9 then: b4, else: b5
  b4():
    v10 = load v1
    v11 = array_get v3, index v4
    v12 = cast v4 as Field
    v13 = cast v11 as u32
    v14 = array_set v10, index v13, value v12
    v15 = add v13, u32 1
    store v14 at v1
    jmp b5()
  b5():
    v16 = add v4, u32 1
    jmp b1(v16)
  b3():
    v17 = load v1
    dec_rc v0
    return v17
}

After Inlining:
acir(inline) fn main f0 {
  b0(v0: [Field; 2], v1: [u1; 2], v2: [u64; 2]):
    v3 = allocate
    store v0 at v3
    inc_rc v0
    jmp b1(u32 0)
  b1(v4: u32):
    v7 = lt v4, u32 2
    jmpif v7 then: b2, else: b3
  b2():
    v9 = array_get v1, index v4
    jmpif v9 then: b4, else: b5
  b4():
    v12 = load v3
    v13 = array_get v2, index v4
    v14 = cast v4 as Field
    v15 = cast v13 as u32
    v16 = array_set v12, index v15, value v14
    v17 = add v15, u32 1
    store v16 at v3
    jmp b5()
  b5():
    v11 = add v4, u32 1
    jmp b1(v11)
  b3():
    v8 = load v3
    dec_rc v0
    return v8
}

After Mem2Reg:
acir(inline) fn main f0 {
  b0(v0: [Field; 2], v1: [u1; 2], v2: [u64; 2]):
    v18 = allocate
    store v0 at v18
    inc_rc v0
    jmp b1(u32 0)
  b1(v4: u32):
    v19 = lt v4, u32 2
    jmpif v19 then: b2, else: b3
  b2():
    v21 = array_get v1, index v4
    jmpif v21 then: b4, else: b5
  b4():
    v22 = load v18
    v23 = array_get v2, index v4
    v24 = cast v4 as Field
    v25 = cast v23 as u32
    v26 = array_set v22, index v25, value v24
    v27 = add v25, u32 1
    store v26 at v18
    jmp b5()
  b5():
    v28 = add v4, u32 1
    jmp b1(v28)
  b3():
    v20 = load v18
    dec_rc v0
    return v20
}

After `as_slice` optimization
acir(inline) fn main f0 {
  b0(v0: [Field; 2], v1: [u1; 2], v2: [u64; 2]):
    v18 = allocate
    store v0 at v18
    inc_rc v0
    jmp b1(u32 0)
  b1(v4: u32):
    v19 = lt v4, u32 2
    jmpif v19 then: b2, else: b3
  b2():
    v21 = array_get v1, index v4
    jmpif v21 then: b4, else: b5
  b4():
    v22 = load v18
    v23 = array_get v2, index v4
    v24 = cast v4 as Field
    v25 = cast v23 as u32
    v26 = array_set v22, index v25, value v24
    v27 = add v25, u32 1
    store v26 at v18
    jmp b5()
  b5():
    v28 = add v4, u32 1
    jmp b1(v28)
  b3():
    v20 = load v18
    dec_rc v0
    return v20
}

After `static_assert` and `assert_constant`:
acir(inline) fn main f0 {
  b0(v0: [Field; 2], v1: [u1; 2], v2: [u64; 2]):
    v18 = allocate
    store v0 at v18
    inc_rc v0
    jmp b1(u32 0)
  b1(v4: u32):
    v19 = lt v4, u32 2
    jmpif v19 then: b2, else: b3
  b2():
    v21 = array_get v1, index v4
    jmpif v21 then: b4, else: b5
  b4():
    v22 = load v18
    v23 = array_get v2, index v4
    v24 = cast v4 as Field
    v25 = cast v23 as u32
    v26 = array_set v22, index v25, value v24
    v27 = add v25, u32 1
    store v26 at v18
    jmp b5()
  b5():
    v28 = add v4, u32 1
    jmp b1(v28)
  b3():
    v20 = load v18
    dec_rc v0
    return v20
}

After Unrolling:
acir(inline) fn main f0 {
  b0(v0: [Field; 2], v1: [u1; 2], v2: [u64; 2]):
    v18 = allocate
    store v0 at v18
    inc_rc v0
    v32 = array_get v1, index u32 0
    jmpif v32 then: b8, else: b9
  b8():
    v34 = load v18
    v35 = array_get v2, index u32 0
    v37 = cast v35 as u32
    v38 = array_set v34, index v37, value Field 0
    v39 = add v37, u32 1
    store v38 at v18
    jmp b9()
  b9():
    v40 = array_get v1, index u32 1
    jmpif v40 then: b13, else: b14
  b13():
    v42 = load v18
    v43 = array_get v2, index u32 1
    v45 = cast v43 as u32
    v46 = array_set v42, index v45, value Field 1
    v47 = add v45, u32 1
    store v46 at v18
    jmp b14()
  b14():
    jmp b3()
  b3():
    v20 = load v18
    dec_rc v0
    return v20
}

After Simplifying:
acir(inline) fn main f0 {
  b0(v0: [Field; 2], v1: [u1; 2], v2: [u64; 2]):
    v18 = allocate
    store v0 at v18
    inc_rc v0
    v32 = array_get v1, index u32 0
    jmpif v32 then: b8, else: b9
  b8():
    v34 = load v18
    v35 = array_get v2, index u32 0
    v37 = cast v35 as u32
    v38 = array_set v34, index v37, value Field 0
    v39 = add v37, u32 1
    store v38 at v18
    jmp b9()
  b9():
    v40 = array_get v1, index u32 1
    jmpif v40 then: b13, else: b14
  b13():
    v42 = load v18
    v43 = array_get v2, index u32 1
    v45 = cast v43 as u32
    v46 = array_set v42, index v45, value Field 1
    v47 = add v45, u32 1
    store v46 at v18
    jmp b14()
  b14():
    v20 = load v18
    dec_rc v0
    return v20
}

After Flattening:
acir(inline) fn main f0 {
  b0(v0: [Field; 2], v1: [u1; 2], v2: [u64; 2]):
    v18 = allocate
    store v0 at v18
    inc_rc v0
    v32 = array_get v1, index u32 0
    enable_side_effects v32
    v49 = load v18
    v50 = array_get v2, index u32 0
    v51 = cast v50 as u32
    v52 = array_set v49, index v51, value Field 0
    v53 = add v51, u32 1
    v54 = load v18
    store v52 at v18
    v55 = not v32
    store v54 at v18
    enable_side_effects u1 1
    v56 = if v32 then v52 else if v55 then v54
    store v56 at v18
    v57 = array_get v1, index u32 1
    enable_side_effects v57
    v58 = load v18
    v59 = array_get v2, index u32 1
    v60 = cast v59 as u32
    v61 = array_set v58, index v60, value Field 1
    v62 = add v60, u32 1
    v63 = load v18
    store v61 at v18
    v64 = not v57
    store v63 at v18
    enable_side_effects u1 1
    v65 = if v57 then v61 else if v64 then v63
    store v65 at v18
    v66 = load v18
    dec_rc v0
    return v66
}

After Removing Bit Shifts:
acir(inline) fn main f0 {
  b0(v0: [Field; 2], v1: [u1; 2], v2: [u64; 2]):
    v18 = allocate
    store v0 at v18
    inc_rc v0
    v32 = array_get v1, index u32 0
    enable_side_effects v32
    v49 = load v18
    v50 = array_get v2, index u32 0
    v51 = cast v50 as u32
    v52 = array_set v49, index v51, value Field 0
    v53 = add v51, u32 1
    v54 = load v18
    store v52 at v18
    v55 = not v32
    store v54 at v18
    enable_side_effects u1 1
    v56 = if v32 then v52 else if v55 then v54
    store v56 at v18
    v57 = array_get v1, index u32 1
    enable_side_effects v57
    v58 = load v18
    v59 = array_get v2, index u32 1
    v60 = cast v59 as u32
    v61 = array_set v58, index v60, value Field 1
    v62 = add v60, u32 1
    v63 = load v18
    store v61 at v18
    v64 = not v57
    store v63 at v18
    enable_side_effects u1 1
    v65 = if v57 then v61 else if v64 then v63
    store v65 at v18
    v66 = load v18
    dec_rc v0
    return v66
}

After Mem2Reg:
acir(inline) fn main f0 {
  b0(v0: [Field; 2], v1: [u1; 2], v2: [u64; 2]):
    v67 = allocate
    inc_rc v0
    v68 = array_get v1, index u32 0
    enable_side_effects v68
    v70 = array_get v2, index u32 0
    v71 = cast v70 as u32
    v72 = array_set v0, index v71, value Field 0
    v73 = add v71, u32 1
    v75 = not v68
    enable_side_effects u1 1
    v76 = if v68 then v72 else if v75 then v0
    v77 = array_get v1, index u32 1
    enable_side_effects v77
    v79 = array_get v2, index u32 1
    v80 = cast v79 as u32
    v81 = array_set v76, index v80, value Field 1
    v82 = add v80, u32 1
    v84 = not v77
    enable_side_effects u1 1
    v85 = if v77 then v81 else if v84 then v76
    dec_rc v0
    return v85
}

After Inlining:
acir(inline) fn main f0 {
  b0(v0: [Field; 2], v1: [u1; 2], v2: [u64; 2]):
    v3 = allocate
    inc_rc v0
    v5 = array_get v1, index u32 0
    enable_side_effects v5
    v6 = array_get v2, index u32 0
    v7 = cast v6 as u32
    v9 = array_set v0, index v7, value Field 0
    v11 = add v7, u32 1
    v12 = not v5
    enable_side_effects u1 1
    v14 = if v5 then v9 else if v12 then v0
    v15 = array_get v1, index u32 1
    enable_side_effects v15
    v16 = array_get v2, index u32 1
    v17 = cast v16 as u32
    v19 = array_set v14, index v17, value Field 1
    v20 = add v17, u32 1
    v21 = not v15
    enable_side_effects u1 1
    v22 = if v15 then v19 else if v21 then v14
    dec_rc v0
    return v22
}

After Remove IfElse:
acir(inline) fn main f0 {
  b0(v0: [Field; 2], v1: [u1; 2], v2: [u64; 2]):
    v3 = allocate
    inc_rc v0
    v5 = array_get v1, index u32 0
    enable_side_effects v5
    v6 = array_get v2, index u32 0
    v7 = cast v6 as u32
    v9 = array_set v0, index v7, value Field 0
    v11 = add v7, u32 1
    v12 = not v5
    enable_side_effects v5
    v23 = array_set v9, index v7, value Field 0
    enable_side_effects u1 1
    v15 = array_get v1, index u32 1
    enable_side_effects v15
    v16 = array_get v2, index u32 1
    v17 = cast v16 as u32
    v19 = array_set v23, index v17, value Field 1
    v20 = add v17, u32 1
    v21 = not v15
    enable_side_effects v15
    v24 = array_set v19, index v17, value Field 1
    enable_side_effects u1 1
    dec_rc v0
    return v24
}

After Constant Folding:
acir(inline) fn main f0 {
  b0(v0: [Field; 2], v1: [u1; 2], v2: [u64; 2]):
    v25 = allocate
    inc_rc v0
    v26 = array_get v1, index u32 0
    enable_side_effects v26
    v27 = array_get v2, index u32 0
    v28 = cast v27 as u32
    v29 = array_set v0, index v28, value Field 0
    v30 = add v28, u32 1
    v31 = not v26
    enable_side_effects v26
    v32 = array_set v29, index v28, value Field 0
    enable_side_effects u1 1
    v33 = array_get v1, index u32 1
    enable_side_effects v33
    v34 = array_get v2, index u32 1
    v35 = cast v34 as u32
    v36 = array_set v32, index v35, value Field 1
    v37 = add v35, u32 1
    v38 = not v33
    enable_side_effects v33
    v39 = array_set v36, index v35, value Field 1
    enable_side_effects u1 1
    dec_rc v0
    return v39
}

After EnableSideEffects removal:
acir(inline) fn main f0 {
  b0(v0: [Field; 2], v1: [u1; 2], v2: [u64; 2]):
    v25 = allocate
    inc_rc v0
    v26 = array_get v1, index u32 0
    enable_side_effects v26
    v27 = array_get v2, index u32 0
    v28 = cast v27 as u32
    v29 = array_set v0, index v28, value Field 0
    v30 = add v28, u32 1
    v31 = not v26
    v32 = array_set v29, index v28, value Field 0
    enable_side_effects u1 1
    v33 = array_get v1, index u32 1
    enable_side_effects v33
    v34 = array_get v2, index u32 1
    v35 = cast v34 as u32
    v36 = array_set v32, index v35, value Field 1
    v37 = add v35, u32 1
    v38 = not v33
    v39 = array_set v36, index v35, value Field 1
    enable_side_effects u1 1
    dec_rc v0
    return v39
}

After Constraint Folding:
acir(inline) fn main f0 {
  b0(v0: [Field; 2], v1: [u1; 2], v2: [u64; 2]):
    v40 = allocate
    inc_rc v0
    v41 = array_get v1, index u32 0
    enable_side_effects v41
    v42 = array_get v2, index u32 0
    v43 = cast v42 as u32
    v44 = array_set v0, index v43, value Field 0
    v45 = add v43, u32 1
    v46 = not v41
    v47 = array_set v44, index v43, value Field 0
    enable_side_effects u1 1
    v48 = array_get v1, index u32 1
    enable_side_effects v48
    v49 = array_get v2, index u32 1
    v50 = cast v49 as u32
    v51 = array_set v47, index v50, value Field 1
    v52 = add v50, u32 1
    v53 = not v48
    v54 = array_set v51, index v50, value Field 1
    enable_side_effects u1 1
    dec_rc v0
    return v54
}

After Dead Instruction Elimination:
acir(inline) fn main f0 {
  b0(v0: [Field; 2], v1: [u1; 2], v2: [u64; 2]):
    inc_rc v0
    v41 = array_get v1, index u32 0
    enable_side_effects v41
    v42 = array_get v2, index u32 0
    v43 = cast v42 as u32
    v44 = array_set v0, index v43, value Field 0
    v47 = array_set v44, index v43, value Field 0
    enable_side_effects u1 1
    v48 = array_get v1, index u32 1
    enable_side_effects v48
    v49 = array_get v2, index u32 1
    v50 = cast v49 as u32
    v51 = array_set v47, index v50, value Field 1
    v54 = array_set v51, index v50, value Field 1
    enable_side_effects u1 1
    dec_rc v0
    return v54
}

After Array Set Optimizations:
acir(inline) fn main f0 {
  b0(v0: [Field; 2], v1: [u1; 2], v2: [u64; 2]):
    inc_rc v0
    v41 = array_get v1, index u32 0
    enable_side_effects v41
    v42 = array_get v2, index u32 0
    v43 = cast v42 as u32
    v44 = array_set mut v0, index v43, value Field 0
    v47 = array_set mut v44, index v43, value Field 0
    enable_side_effects u1 1
    v48 = array_get v1, index u32 1
    enable_side_effects v48
    v49 = array_get v2, index u32 1
    v50 = cast v49 as u32
    v51 = array_set mut v47, index v50, value Field 1
    v54 = array_set mut v51, index v50, value Field 1
    enable_side_effects u1 1
    dec_rc v0
    return v54
}

[regression_5027] Circuit witness successfully solved
[regression_5027] Circuit output: Vec([Field(0), Field(0)])
