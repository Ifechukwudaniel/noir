Initial SSA:
brillig fn main f0 {
  b0(v0: [Field, Field; 6]):
    inc_rc v0
    v2 = array_get v0, index u32 0
    v4 = array_get v0, index u32 1
    v5 = array_get v0, index u32 0
    v6 = array_get v0, index u32 1
    call f1(v2, v6)
    dec_rc v0
    return 
}
brillig fn test_sequential f1 {
  b0(v0: Field, v1: Field):
    v3, v4, v5 = call f2()
    v6 = allocate
    store v3 at v6
    inc_rc v4
    v7 = allocate
    store v4 at v7
    v8 = allocate
    store v5 at v8
    v9 = load v6
    v10 = load v7
    v11 = load v8
    v13 = call f3(v9, v10, v11)
    constrain v13 == u1 1 '"New UHashMap should be empty."'
    call f4(v6, v7, v8, v0, v1)
    v16 = load v6
    v17 = load v7
    v18 = load v8
    v20 = call f5(v16, v17, v18)
    v22 = eq v20, u32 1
    constrain v20 == u32 1 '"UHashMap after one insert should have a length of 1 element."'
    return 
}
acir(inline) fn lambda f2 {
  b0():
    v1, v2, v3 = call f33()
    return v1, v2, v3
}
acir(inline) fn is_empty f3 {
  b0(v0: u32, v1: [u1, Field, Field, u1], v2: u32):
    inc_rc v1
    v4 = eq v2, u32 0
    dec_rc v1
    return v4
}
brillig fn insert f4 {
  b0(v0: &mut u32, v1: &mut [u1, Field, Field, u1], v2: &mut u32, v3: Field, v4: Field):
    v6 = load v1
    inc_rc v6
    call f6(v0, v1, v2)
    v8 = load v0
    v9 = load v1
    v10 = load v2
    v12 = call f7(v8, v9, v10, v3)
    v13 = load v0
    v14 = load v1
    v15 = load v2
    jmp b1(u32 0)
  b1(v5: u32):
    v17 = lt v5, v13
    jmpif v17 then: b2, else: b10
  b2():
    v18 = load v0
    v19 = load v1
    v20 = load v2
    v22 = call f8(v18, v19, v20, v12, v5)
    v23 = load v0
    v24 = load v1
    v25 = load v2
    v27 = mul v22, u32 4
    v28 = lt v22, v23
    constrain v28 == u1 1 '"Index out of bounds"'
    v30 = array_get v24, index v27
    v32 = add v27, u32 1
    v33 = lt v22, v23
    constrain v33 == u1 1 '"Index out of bounds"'
    v34 = array_get v24, index v32
    v36 = add v27, u32 2
    v37 = lt v22, v23
    constrain v37 == u1 1 '"Index out of bounds"'
    v38 = array_get v24, index v36
    v40 = add v27, u32 3
    v41 = lt v22, v23
    constrain v41 == u1 1 '"Index out of bounds"'
    v42 = array_get v24, index v40
    v43 = allocate
    store v30 at v43
    v44 = allocate
    store v34 at v44
    v45 = allocate
    store v38 at v45
    v46 = allocate
    store v42 at v46
    v47 = allocate
    store u1 0 at v47
    v49 = load v43
    v50 = load v44
    v51 = load v45
    v52 = load v46
    v54 = call f9(v49, v50, v51, v52)
    jmpif v54 then: b6, else: b3
  b6():
    store u1 1 at v47
    v64 = load v0
    v65 = load v1
    v66 = load v2
    v67 = load v0
    v68 = load v1
    v69 = load v2
    v70 = add v69, u32 1
    store v64 at v0
    store v65 at v1
    store v70 at v2
    jmp b7()
  b7():
    v71 = load v47
    jmpif v71 then: b9, else: b8
  b9():
    call f12(v43, v44, v45, v46, v3, v4)
    v74 = load v0
    v75 = load v1
    v76 = load v2
    v77 = load v43
    v78 = load v44
    v79 = load v45
    v80 = load v46
    v81 = mul v22, u32 4
    v82 = array_set v75, index v81, value v77
    v83 = add v81, u32 1
    v84 = array_set v82, index v83, value v78
    v85 = add v83, u32 1
    v86 = array_set v84, index v85, value v79
    v87 = add v85, u32 1
    v88 = array_set v86, index v87, value v80
    v89 = add v87, u32 1
    store v74 at v0
    store v88 at v1
    store v76 at v2
    jmp b10()
  b10():
    v90 = load v1
    dec_rc v90
    return 
  b8():
    v72 = add v5, u32 1
    jmp b1(v72)
  b3():
    v55 = load v43
    v56 = load v44
    v57 = load v45
    v58 = load v46
    v60, v61 = call f10(v55, v56, v57, v58)
    v63 = call f11(v60, v3)
    jmpif v63 then: b4, else: b5
  b4():
    store u1 1 at v47
    jmp b5()
  b5():
    jmp b7()
}
acir(inline) fn len f5 {
  b0(v0: u32, v1: [u1, Field, Field, u1], v2: u32):
    inc_rc v1
    dec_rc v1
    return v2
}
brillig fn try_resize f6 {
  b0(v0: &mut u32, v1: &mut [u1, Field, Field, u1], v2: &mut u32):
    v4 = load v1
    inc_rc v4
    v5 = load v0
    v6 = load v1
    v7 = load v2
    v9 = call f5(v5, v6, v7)
    v11 = add v9, u32 1
    v12 = load v0
    v13 = load v1
    v14 = load v2
    v16 = call f25(v12, v13, v14)
    v18 = div v16, u32 2
    v19 = lt v11, v18
    v20 = not v19
    jmpif v20 then: b1, else: b4
  b1():
    v21 = load v0
    v22 = load v1
    v23 = load v2
    v25 = call f25(v21, v22, v23)
    v26 = mul v25, u32 2
    v27 = load v0
    v28 = load v1
    v29 = load v2
    v31, v32, v33 = call f26(v26)
    v34 = allocate
    store v31 at v34
    inc_rc v32
    v35 = allocate
    store v32 at v35
    v36 = allocate
    store v33 at v36
    v37 = load v0
    v38 = load v1
    v39 = load v2
    v41, v42 = call f27(v37, v38, v39)
    inc_rc v42
    jmp b2(u32 0)
  b2(v3: u32):
    v44 = lt v3, v41
    jmpif v44 then: b5, else: b3
  b5():
    v49 = mul v3, u32 2
    v50 = lt v3, v41
    constrain v50 == u1 1 '"Index out of bounds"'
    v52 = array_get v42, index v49
    v53 = add v49, u32 1
    v54 = lt v3, v41
    constrain v54 == u1 1 '"Index out of bounds"'
    v55 = array_get v42, index v53
    call f4(v34, v35, v36, v52, v55)
    v57 = add v3, u32 1
    jmp b2(v57)
  b3():
    v45 = load v34
    v46 = load v35
    v47 = load v36
    inc_rc v46
    store v45 at v0
    store v46 at v1
    store v47 at v2
    jmp b4()
  b4():
    v48 = load v1
    dec_rc v48
    return 
}
acir(inline) fn hash f7 {
  b0(v0: u32, v1: [u1, Field, Field, u1], v2: u32, v3: Field):
    inc_rc v1
    v5, v6 = call f16()
    v7 = allocate
    store v5 at v7
    inc_rc v6
    v8 = allocate
    store v6 at v8
    call f17(v3, v7, v8)
    v10 = load v7
    v11 = load v8
    v13 = call f18(v10, v11)
    v14 = truncate v13 to 32 bits, max_bit_size: 254
    v15 = cast v14 as u32
    dec_rc v1
    return v15
}
acir(inline) fn quadratic_probe f8 {
  b0(v0: u32, v1: [u1, Field, Field, u1], v2: u32, v3: u32, v4: u32):
    inc_rc v1
    v5 = mul v4, v4
    v6 = add v4, v5
    v8 = div v6, u32 2
    v9 = add v3, v8
    v10 = mod v9, v0
    dec_rc v1
    return v10
}
acir(inline) fn is_available f9 {
  b0(v0: u1, v1: Field, v2: Field, v3: u1):
    v5 = call f15(v0, v1, v2)
    v6 = or v3, v5
    return v6
}
acir(inline) fn key_value_unchecked f10 {
  b0(v0: u1, v1: Field, v2: Field, v3: u1):
    v5, v6 = call f14(v0, v1, v2)
    return v5, v6
}
acir(inline) fn eq f11 {
  b0(v0: Field, v1: Field):
    v2 = eq v0, v1
    return v2
}
acir(inline) fn set f12 {
  b0(v0: &mut u1, v1: &mut Field, v2: &mut Field, v3: &mut u1, v4: Field, v5: Field):
    v6 = load v0
    v7 = load v1
    v8 = load v2
    v9 = load v3
    v11, v12, v13 = call f13(v4, v5)
    store v11 at v0
    store v12 at v1
    store v13 at v2
    store v9 at v3
    v14 = load v0
    v15 = load v1
    v16 = load v2
    v17 = load v3
    store v14 at v0
    store v15 at v1
    store v16 at v2
    store u1 0 at v3
    return 
}
acir(inline) fn some f13 {
  b0(v0: Field, v1: Field):
    return u1 1, v0, v1
}
acir(inline) fn unwrap_unchecked f14 {
  b0(v0: u1, v1: Field, v2: Field):
    return v1, v2
}
acir(inline) fn is_none f15 {
  b0(v0: u1, v1: Field, v2: Field):
    v3 = not v0
    return v3
}
acir(inline) fn build_hasher f16 {
  b0():
    v1, v2 = call f24()
    return v1, v2
}
acir(inline) fn hash f17 {
  b0(v0: Field, v1: &mut u32, v2: &mut [Field]):
    v3 = load v2
    inc_rc v3
    call f23(v1, v2, v0)
    v5 = load v2
    dec_rc v5
    return 
}
acir(inline) fn finish f18 {
  b0(v0: u32, v1: [Field]):
    inc_rc v1
    v3 = cast v0 as Field
    v5 = mul v3, Field 2⁶⁴
    v7, v8, v9, v10 = call f19(v5)
    inc_rc v7
    v11 = allocate
    store v7 at v11
    inc_rc v8
    v12 = allocate
    store v8 at v12
    v13 = allocate
    store v9 at v13
    v14 = allocate
    store v10 at v14
    jmp b1(u32 0)
  b1(v2: u32):
    v16 = lt v2, v0
    jmpif v16 then: b3, else: b2
  b3():
    v19 = lt v2, v0
    constrain v19 == u1 1 '"Index out of bounds"'
    v21 = array_get v1, index v2
    call f20(v11, v12, v13, v14, v21)
    v24 = add v2, u32 1
    jmp b1(v24)
  b2():
    v18 = call f21(v11, v12, v13, v14)
    dec_rc v1
    return v18
}
acir(inline) fn new f19 {
  b0(v0: Field):
    inc_rc [Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0]
    v4 = allocate
    store [Field 0, Field 0, Field 0] at v4
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    v5 = allocate
    store [Field 0, Field 0, Field 0, Field 0] at v5
    v6 = allocate
    store u32 0 at v6
    v8 = allocate
    store u1 0 at v8
    v10 = load v4
    v11 = load v5
    v12 = load v6
    v13 = load v8
    v15 = array_set v11, index u32 3, value v0
    store v10 at v4
    store v15 at v5
    store v12 at v6
    store v13 at v8
    v16 = load v4
    v17 = load v5
    v18 = load v6
    v19 = load v8
    return v16, v17, v18, v19
}
acir(inline) fn absorb f20 {
  b0(v0: &mut [Field; 3], v1: &mut [Field; 4], v2: &mut u32, v3: &mut u1, v4: Field):
    v5 = load v0
    inc_rc v5
    v6 = load v1
    inc_rc v6
    v7 = load v0
    v8 = load v1
    v9 = load v2
    v10 = load v3
    v11 = not v10
    constrain v10 == u1 0
    v13 = load v0
    v14 = load v1
    v15 = load v2
    v16 = load v3
    v18 = eq v15, u32 3
    jmpif v18 then: b2, else: b1
  b2():
    call f22(v0, v1, v2, v3)
    v40 = load v0
    v41 = load v1
    v42 = load v2
    v43 = load v3
    v45 = array_set v40, index u32 0, value v4
    store v45 at v0
    store v41 at v1
    store v42 at v2
    store v43 at v3
    v46 = load v0
    v47 = load v1
    v48 = load v2
    v49 = load v3
    store v46 at v0
    store v47 at v1
    store u32 1 at v2
    store v49 at v3
    jmp b3()
  b3():
    v50 = load v0
    dec_rc v50
    v51 = load v1
    dec_rc v51
    return 
  b1():
    v19 = load v0
    v20 = load v1
    v21 = load v2
    v22 = load v3
    v23 = load v0
    v24 = load v1
    v25 = load v2
    v26 = load v3
    v27 = array_set v19, index v25, value v4
    v29 = add v25, u32 1
    store v27 at v0
    store v20 at v1
    store v21 at v2
    store v22 at v3
    v30 = load v0
    v31 = load v1
    v32 = load v2
    v33 = load v3
    v34 = load v0
    v35 = load v1
    v36 = load v2
    v37 = load v3
    v38 = add v36, u32 1
    store v30 at v0
    store v31 at v1
    store v38 at v2
    store v33 at v3
    jmp b3()
}
acir(inline) fn squeeze f21 {
  b0(v0: &mut [Field; 3], v1: &mut [Field; 4], v2: &mut u32, v3: &mut u1):
    v4 = load v0
    inc_rc v4
    v5 = load v1
    inc_rc v5
    v6 = load v0
    v7 = load v1
    v8 = load v2
    v9 = load v3
    v10 = not v9
    constrain v9 == u1 0
    call f22(v0, v1, v2, v3)
    v13 = load v0
    v14 = load v1
    v15 = load v2
    v16 = load v3
    store v13 at v0
    store v14 at v1
    store v15 at v2
    store u1 1 at v3
    v18 = load v0
    v19 = load v1
    v20 = load v2
    v21 = load v3
    v23 = array_get v19, index u32 0
    v24 = load v0
    dec_rc v24
    v25 = load v1
    dec_rc v25
    return v23
}
acir(inline) fn perform_duplex f22 {
  b0(v0: &mut [Field; 3], v1: &mut [Field; 4], v2: &mut u32, v3: &mut u1):
    v5 = load v0
    inc_rc v5
    v6 = load v1
    inc_rc v6
    jmp b1(u32 0)
  b1(v4: u32):
    v9 = lt v4, u32 3
    jmpif v9 then: b3, else: b2
  b3():
    v23 = load v0
    v24 = load v1
    v25 = load v2
    v26 = load v3
    v27 = lt v4, v25
    jmpif v27 then: b4, else: b5
  b4():
    v28 = load v0
    v29 = load v1
    v30 = load v2
    v31 = load v3
    v32 = load v0
    v33 = load v1
    v34 = load v2
    v35 = load v3
    v36 = array_get v33, index v4
    v37 = load v0
    v38 = load v1
    v39 = load v2
    v40 = load v3
    v41 = array_get v37, index v4
    v42 = add v36, v41
    v43 = array_set v29, index v4, value v42
    v45 = add v4, u32 1
    store v28 at v0
    store v43 at v1
    store v30 at v2
    store v31 at v3
    jmp b5()
  b5():
    v46 = add v4, u32 1
    jmp b1(v46)
  b2():
    v10 = load v0
    v11 = load v1
    v12 = load v2
    v13 = load v3
    v14 = load v0
    v15 = load v1
    v16 = load v2
    v17 = load v3
    v20 = call poseidon2_permutation(v15, u32 4)
    inc_rc v20
    store v10 at v0
    store v20 at v1
    store v12 at v2
    store v13 at v3
    v21 = load v0
    dec_rc v21
    v22 = load v1
    dec_rc v22
    return 
}
acir(inline) fn write f23 {
  b0(v0: &mut u32, v1: &mut [Field], v2: Field):
    v3 = load v1
    inc_rc v3
    v4 = load v0
    v5 = load v1
    v6 = load v0
    v7 = load v1
    v9, v10 = call slice_push_back(v6, v7, v2)
    inc_rc v10
    store v9 at v0
    store v10 at v1
    v11 = load v1
    dec_rc v11
    return 
}
acir(inline) fn default f24 {
  b0():
    inc_rc []
    return u32 0, []
}
acir(inline) fn capacity f25 {
  b0(v0: u32, v1: [u1, Field, Field, u1], v2: u32):
    inc_rc v1
    dec_rc v1
    return v0
}
acir(inline) fn with_hasher_and_capacity f26 {
  b0(v0: u32):
    v2 = allocate
    store u32 0 at v2
    inc_rc []
    v5 = allocate
    store [] at v5
    jmp b1(u32 0)
  b1(v1: u32):
    v6 = lt v1, v0
    jmpif v6 then: b3, else: b2
  b3():
    v9 = load v2
    v10 = load v5
    v12, v13, v14, v15 = call f31()
    v17, v18 = call slice_push_back(v9, v10, v12, v13, v14, v15)
    inc_rc v18
    store v17 at v2
    store v18 at v5
    v20 = add v1, u32 1
    jmp b1(v20)
  b2():
    v7 = load v2
    v8 = load v5
    inc_rc v8
    return v7, v8, u32 0
}
acir(inline) fn entries f27 {
  b0(v0: u32, v1: [u1, Field, Field, u1], v2: u32):
    inc_rc v1
    v4 = allocate
    store u32 0 at v4
    inc_rc []
    v7 = allocate
    store [] at v7
    inc_rc v1
    jmp b1(u32 0)
  b1(v3: u32):
    v8 = lt v3, v0
    jmpif v8 then: b3, else: b2
  b3():
    v42 = mul v3, u32 4
    v43 = lt v3, v0
    constrain v43 == u1 1 '"Index out of bounds"'
    v45 = array_get v1, index v42
    v47 = add v42, u32 1
    v48 = lt v3, v0
    constrain v48 == u1 1 '"Index out of bounds"'
    v49 = array_get v1, index v47
    v51 = add v42, u32 2
    v52 = lt v3, v0
    constrain v52 == u1 1 '"Index out of bounds"'
    v53 = array_get v1, index v51
    v55 = add v42, u32 3
    v56 = lt v3, v0
    constrain v56 == u1 1 '"Index out of bounds"'
    v57 = array_get v1, index v55
    v59 = call f28(v45, v49, v53, v57)
    jmpif v59 then: b4, else: b5
  b4():
    v61, v62, v63 = call f29(v45, v49, v53, v57)
    v65, v66 = call f14(v61, v62, v63)
    v67 = load v4
    v68 = load v7
    v70, v71 = call slice_push_back(v67, v68, v65, v66)
    inc_rc v71
    store v70 at v4
    store v71 at v7
    jmp b5()
  b5():
    v72 = add v3, u32 1
    jmp b1(v72)
  b2():
    inc_rc [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46]
    v36 = load v4
    v37 = load v7
    v38 = eq v36, v2
    constrain v36 == v2, data [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46], u32 0
    v39 = load v4
    v40 = load v7
    dec_rc v1
    return v39, v40
}
acir(inline) fn is_valid f28 {
  b0(v0: u1, v1: Field, v2: Field, v3: u1):
    v4 = not v3
    v6 = call f30(v0, v1, v2)
    v7 = mul v4, v6
    return v7
}
acir(inline) fn key_value f29 {
  b0(v0: u1, v1: Field, v2: Field, v3: u1):
    return v0, v1, v2
}
acir(inline) fn is_some f30 {
  b0(v0: u1, v1: Field, v2: Field):
    return v0
}
acir(inline) fn default f31 {
  b0():
    v1, v2, v3 = call f32()
    return v1, v2, v3, u1 0
}
acir(inline) fn none f32 {
  b0():
    return u1 0, Field 0, Field 0
}
acir(inline) fn default f33 {
  b0():
    call f35()
    v2, v3, v4 = call f34()
    return v2, v3, v4
}
acir(inline) fn with_hasher f34 {
  b0():
    v1, v2, v3, v4 = call f31()
    inc_rc [v1, v2, v3, v4]
    inc_rc [v1, v2, v3, v4]
    return u32 1, [v1, v2, v3, v4], u32 0
}
acir(inline) fn default f35 {
  b0():
    return 
}

After Defunctionalization:
brillig fn main f0 {
  b0(v0: [Field, Field; 6]):
    inc_rc v0
    v2 = array_get v0, index u32 0
    v4 = array_get v0, index u32 1
    v5 = array_get v0, index u32 0
    v6 = array_get v0, index u32 1
    call f1(v2, v6)
    dec_rc v0
    return 
}
brillig fn test_sequential f1 {
  b0(v0: Field, v1: Field):
    v3, v4, v5 = call f2()
    v6 = allocate
    store v3 at v6
    inc_rc v4
    v7 = allocate
    store v4 at v7
    v8 = allocate
    store v5 at v8
    v9 = load v6
    v10 = load v7
    v11 = load v8
    v13 = call f3(v9, v10, v11)
    constrain v13 == u1 1 '"New UHashMap should be empty."'
    call f4(v6, v7, v8, v0, v1)
    v16 = load v6
    v17 = load v7
    v18 = load v8
    v20 = call f5(v16, v17, v18)
    v22 = eq v20, u32 1
    constrain v20 == u32 1 '"UHashMap after one insert should have a length of 1 element."'
    return 
}
acir(inline) fn lambda f2 {
  b0():
    v1, v2, v3 = call f33()
    return v1, v2, v3
}
acir(inline) fn is_empty f3 {
  b0(v0: u32, v1: [u1, Field, Field, u1], v2: u32):
    inc_rc v1
    v4 = eq v2, u32 0
    dec_rc v1
    return v4
}
brillig fn insert f4 {
  b0(v0: &mut u32, v1: &mut [u1, Field, Field, u1], v2: &mut u32, v3: Field, v4: Field):
    v6 = load v1
    inc_rc v6
    call f6(v0, v1, v2)
    v8 = load v0
    v9 = load v1
    v10 = load v2
    v12 = call f7(v8, v9, v10, v3)
    v13 = load v0
    v14 = load v1
    v15 = load v2
    jmp b1(u32 0)
  b1(v5: u32):
    v17 = lt v5, v13
    jmpif v17 then: b2, else: b10
  b2():
    v18 = load v0
    v19 = load v1
    v20 = load v2
    v22 = call f8(v18, v19, v20, v12, v5)
    v23 = load v0
    v24 = load v1
    v25 = load v2
    v27 = mul v22, u32 4
    v28 = lt v22, v23
    constrain v28 == u1 1 '"Index out of bounds"'
    v30 = array_get v24, index v27
    v32 = add v27, u32 1
    v33 = lt v22, v23
    constrain v33 == u1 1 '"Index out of bounds"'
    v34 = array_get v24, index v32
    v36 = add v27, u32 2
    v37 = lt v22, v23
    constrain v37 == u1 1 '"Index out of bounds"'
    v38 = array_get v24, index v36
    v40 = add v27, u32 3
    v41 = lt v22, v23
    constrain v41 == u1 1 '"Index out of bounds"'
    v42 = array_get v24, index v40
    v43 = allocate
    store v30 at v43
    v44 = allocate
    store v34 at v44
    v45 = allocate
    store v38 at v45
    v46 = allocate
    store v42 at v46
    v47 = allocate
    store u1 0 at v47
    v49 = load v43
    v50 = load v44
    v51 = load v45
    v52 = load v46
    v54 = call f9(v49, v50, v51, v52)
    jmpif v54 then: b6, else: b3
  b6():
    store u1 1 at v47
    v64 = load v0
    v65 = load v1
    v66 = load v2
    v67 = load v0
    v68 = load v1
    v69 = load v2
    v70 = add v69, u32 1
    store v64 at v0
    store v65 at v1
    store v70 at v2
    jmp b7()
  b7():
    v71 = load v47
    jmpif v71 then: b9, else: b8
  b9():
    call f12(v43, v44, v45, v46, v3, v4)
    v74 = load v0
    v75 = load v1
    v76 = load v2
    v77 = load v43
    v78 = load v44
    v79 = load v45
    v80 = load v46
    v81 = mul v22, u32 4
    v82 = array_set v75, index v81, value v77
    v83 = add v81, u32 1
    v84 = array_set v82, index v83, value v78
    v85 = add v83, u32 1
    v86 = array_set v84, index v85, value v79
    v87 = add v85, u32 1
    v88 = array_set v86, index v87, value v80
    v89 = add v87, u32 1
    store v74 at v0
    store v88 at v1
    store v76 at v2
    jmp b10()
  b10():
    v90 = load v1
    dec_rc v90
    return 
  b8():
    v72 = add v5, u32 1
    jmp b1(v72)
  b3():
    v55 = load v43
    v56 = load v44
    v57 = load v45
    v58 = load v46
    v60, v61 = call f10(v55, v56, v57, v58)
    v63 = call f11(v60, v3)
    jmpif v63 then: b4, else: b5
  b4():
    store u1 1 at v47
    jmp b5()
  b5():
    jmp b7()
}
acir(inline) fn len f5 {
  b0(v0: u32, v1: [u1, Field, Field, u1], v2: u32):
    inc_rc v1
    dec_rc v1
    return v2
}
brillig fn try_resize f6 {
  b0(v0: &mut u32, v1: &mut [u1, Field, Field, u1], v2: &mut u32):
    v4 = load v1
    inc_rc v4
    v5 = load v0
    v6 = load v1
    v7 = load v2
    v9 = call f5(v5, v6, v7)
    v11 = add v9, u32 1
    v12 = load v0
    v13 = load v1
    v14 = load v2
    v16 = call f25(v12, v13, v14)
    v18 = div v16, u32 2
    v19 = lt v11, v18
    v20 = not v19
    jmpif v20 then: b1, else: b4
  b1():
    v21 = load v0
    v22 = load v1
    v23 = load v2
    v25 = call f25(v21, v22, v23)
    v26 = mul v25, u32 2
    v27 = load v0
    v28 = load v1
    v29 = load v2
    v31, v32, v33 = call f26(v26)
    v34 = allocate
    store v31 at v34
    inc_rc v32
    v35 = allocate
    store v32 at v35
    v36 = allocate
    store v33 at v36
    v37 = load v0
    v38 = load v1
    v39 = load v2
    v41, v42 = call f27(v37, v38, v39)
    inc_rc v42
    jmp b2(u32 0)
  b2(v3: u32):
    v44 = lt v3, v41
    jmpif v44 then: b5, else: b3
  b5():
    v49 = mul v3, u32 2
    v50 = lt v3, v41
    constrain v50 == u1 1 '"Index out of bounds"'
    v52 = array_get v42, index v49
    v53 = add v49, u32 1
    v54 = lt v3, v41
    constrain v54 == u1 1 '"Index out of bounds"'
    v55 = array_get v42, index v53
    call f4(v34, v35, v36, v52, v55)
    v57 = add v3, u32 1
    jmp b2(v57)
  b3():
    v45 = load v34
    v46 = load v35
    v47 = load v36
    inc_rc v46
    store v45 at v0
    store v46 at v1
    store v47 at v2
    jmp b4()
  b4():
    v48 = load v1
    dec_rc v48
    return 
}
acir(inline) fn hash f7 {
  b0(v0: u32, v1: [u1, Field, Field, u1], v2: u32, v3: Field):
    inc_rc v1
    v5, v6 = call f16()
    v7 = allocate
    store v5 at v7
    inc_rc v6
    v8 = allocate
    store v6 at v8
    call f17(v3, v7, v8)
    v10 = load v7
    v11 = load v8
    v13 = call f18(v10, v11)
    v14 = truncate v13 to 32 bits, max_bit_size: 254
    v15 = cast v14 as u32
    dec_rc v1
    return v15
}
acir(inline) fn quadratic_probe f8 {
  b0(v0: u32, v1: [u1, Field, Field, u1], v2: u32, v3: u32, v4: u32):
    inc_rc v1
    v5 = mul v4, v4
    v6 = add v4, v5
    v8 = div v6, u32 2
    v9 = add v3, v8
    v10 = mod v9, v0
    dec_rc v1
    return v10
}
acir(inline) fn is_available f9 {
  b0(v0: u1, v1: Field, v2: Field, v3: u1):
    v5 = call f15(v0, v1, v2)
    v6 = or v3, v5
    return v6
}
acir(inline) fn key_value_unchecked f10 {
  b0(v0: u1, v1: Field, v2: Field, v3: u1):
    v5, v6 = call f14(v0, v1, v2)
    return v5, v6
}
acir(inline) fn eq f11 {
  b0(v0: Field, v1: Field):
    v2 = eq v0, v1
    return v2
}
acir(inline) fn set f12 {
  b0(v0: &mut u1, v1: &mut Field, v2: &mut Field, v3: &mut u1, v4: Field, v5: Field):
    v6 = load v0
    v7 = load v1
    v8 = load v2
    v9 = load v3
    v11, v12, v13 = call f13(v4, v5)
    store v11 at v0
    store v12 at v1
    store v13 at v2
    store v9 at v3
    v14 = load v0
    v15 = load v1
    v16 = load v2
    v17 = load v3
    store v14 at v0
    store v15 at v1
    store v16 at v2
    store u1 0 at v3
    return 
}
acir(inline) fn some f13 {
  b0(v0: Field, v1: Field):
    return u1 1, v0, v1
}
acir(inline) fn unwrap_unchecked f14 {
  b0(v0: u1, v1: Field, v2: Field):
    return v1, v2
}
acir(inline) fn is_none f15 {
  b0(v0: u1, v1: Field, v2: Field):
    v3 = not v0
    return v3
}
acir(inline) fn build_hasher f16 {
  b0():
    v1, v2 = call f24()
    return v1, v2
}
acir(inline) fn hash f17 {
  b0(v0: Field, v1: &mut u32, v2: &mut [Field]):
    v3 = load v2
    inc_rc v3
    call f23(v1, v2, v0)
    v5 = load v2
    dec_rc v5
    return 
}
acir(inline) fn finish f18 {
  b0(v0: u32, v1: [Field]):
    inc_rc v1
    v3 = cast v0 as Field
    v5 = mul v3, Field 2⁶⁴
    v7, v8, v9, v10 = call f19(v5)
    inc_rc v7
    v11 = allocate
    store v7 at v11
    inc_rc v8
    v12 = allocate
    store v8 at v12
    v13 = allocate
    store v9 at v13
    v14 = allocate
    store v10 at v14
    jmp b1(u32 0)
  b1(v2: u32):
    v16 = lt v2, v0
    jmpif v16 then: b3, else: b2
  b3():
    v19 = lt v2, v0
    constrain v19 == u1 1 '"Index out of bounds"'
    v21 = array_get v1, index v2
    call f20(v11, v12, v13, v14, v21)
    v24 = add v2, u32 1
    jmp b1(v24)
  b2():
    v18 = call f21(v11, v12, v13, v14)
    dec_rc v1
    return v18
}
acir(inline) fn new f19 {
  b0(v0: Field):
    inc_rc [Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0]
    v4 = allocate
    store [Field 0, Field 0, Field 0] at v4
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    v5 = allocate
    store [Field 0, Field 0, Field 0, Field 0] at v5
    v6 = allocate
    store u32 0 at v6
    v8 = allocate
    store u1 0 at v8
    v10 = load v4
    v11 = load v5
    v12 = load v6
    v13 = load v8
    v15 = array_set v11, index u32 3, value v0
    store v10 at v4
    store v15 at v5
    store v12 at v6
    store v13 at v8
    v16 = load v4
    v17 = load v5
    v18 = load v6
    v19 = load v8
    return v16, v17, v18, v19
}
acir(inline) fn absorb f20 {
  b0(v0: &mut [Field; 3], v1: &mut [Field; 4], v2: &mut u32, v3: &mut u1, v4: Field):
    v5 = load v0
    inc_rc v5
    v6 = load v1
    inc_rc v6
    v7 = load v0
    v8 = load v1
    v9 = load v2
    v10 = load v3
    v11 = not v10
    constrain v10 == u1 0
    v13 = load v0
    v14 = load v1
    v15 = load v2
    v16 = load v3
    v18 = eq v15, u32 3
    jmpif v18 then: b2, else: b1
  b2():
    call f22(v0, v1, v2, v3)
    v40 = load v0
    v41 = load v1
    v42 = load v2
    v43 = load v3
    v45 = array_set v40, index u32 0, value v4
    store v45 at v0
    store v41 at v1
    store v42 at v2
    store v43 at v3
    v46 = load v0
    v47 = load v1
    v48 = load v2
    v49 = load v3
    store v46 at v0
    store v47 at v1
    store u32 1 at v2
    store v49 at v3
    jmp b3()
  b3():
    v50 = load v0
    dec_rc v50
    v51 = load v1
    dec_rc v51
    return 
  b1():
    v19 = load v0
    v20 = load v1
    v21 = load v2
    v22 = load v3
    v23 = load v0
    v24 = load v1
    v25 = load v2
    v26 = load v3
    v27 = array_set v19, index v25, value v4
    v29 = add v25, u32 1
    store v27 at v0
    store v20 at v1
    store v21 at v2
    store v22 at v3
    v30 = load v0
    v31 = load v1
    v32 = load v2
    v33 = load v3
    v34 = load v0
    v35 = load v1
    v36 = load v2
    v37 = load v3
    v38 = add v36, u32 1
    store v30 at v0
    store v31 at v1
    store v38 at v2
    store v33 at v3
    jmp b3()
}
acir(inline) fn squeeze f21 {
  b0(v0: &mut [Field; 3], v1: &mut [Field; 4], v2: &mut u32, v3: &mut u1):
    v4 = load v0
    inc_rc v4
    v5 = load v1
    inc_rc v5
    v6 = load v0
    v7 = load v1
    v8 = load v2
    v9 = load v3
    v10 = not v9
    constrain v9 == u1 0
    call f22(v0, v1, v2, v3)
    v13 = load v0
    v14 = load v1
    v15 = load v2
    v16 = load v3
    store v13 at v0
    store v14 at v1
    store v15 at v2
    store u1 1 at v3
    v18 = load v0
    v19 = load v1
    v20 = load v2
    v21 = load v3
    v23 = array_get v19, index u32 0
    v24 = load v0
    dec_rc v24
    v25 = load v1
    dec_rc v25
    return v23
}
acir(inline) fn perform_duplex f22 {
  b0(v0: &mut [Field; 3], v1: &mut [Field; 4], v2: &mut u32, v3: &mut u1):
    v5 = load v0
    inc_rc v5
    v6 = load v1
    inc_rc v6
    jmp b1(u32 0)
  b1(v4: u32):
    v9 = lt v4, u32 3
    jmpif v9 then: b3, else: b2
  b3():
    v23 = load v0
    v24 = load v1
    v25 = load v2
    v26 = load v3
    v27 = lt v4, v25
    jmpif v27 then: b4, else: b5
  b4():
    v28 = load v0
    v29 = load v1
    v30 = load v2
    v31 = load v3
    v32 = load v0
    v33 = load v1
    v34 = load v2
    v35 = load v3
    v36 = array_get v33, index v4
    v37 = load v0
    v38 = load v1
    v39 = load v2
    v40 = load v3
    v41 = array_get v37, index v4
    v42 = add v36, v41
    v43 = array_set v29, index v4, value v42
    v45 = add v4, u32 1
    store v28 at v0
    store v43 at v1
    store v30 at v2
    store v31 at v3
    jmp b5()
  b5():
    v46 = add v4, u32 1
    jmp b1(v46)
  b2():
    v10 = load v0
    v11 = load v1
    v12 = load v2
    v13 = load v3
    v14 = load v0
    v15 = load v1
    v16 = load v2
    v17 = load v3
    v20 = call poseidon2_permutation(v15, u32 4)
    inc_rc v20
    store v10 at v0
    store v20 at v1
    store v12 at v2
    store v13 at v3
    v21 = load v0
    dec_rc v21
    v22 = load v1
    dec_rc v22
    return 
}
acir(inline) fn write f23 {
  b0(v0: &mut u32, v1: &mut [Field], v2: Field):
    v3 = load v1
    inc_rc v3
    v4 = load v0
    v5 = load v1
    v6 = load v0
    v7 = load v1
    v9, v10 = call slice_push_back(v6, v7, v2)
    inc_rc v10
    store v9 at v0
    store v10 at v1
    v11 = load v1
    dec_rc v11
    return 
}
acir(inline) fn default f24 {
  b0():
    inc_rc []
    return u32 0, []
}
acir(inline) fn capacity f25 {
  b0(v0: u32, v1: [u1, Field, Field, u1], v2: u32):
    inc_rc v1
    dec_rc v1
    return v0
}
acir(inline) fn with_hasher_and_capacity f26 {
  b0(v0: u32):
    v2 = allocate
    store u32 0 at v2
    inc_rc []
    v5 = allocate
    store [] at v5
    jmp b1(u32 0)
  b1(v1: u32):
    v6 = lt v1, v0
    jmpif v6 then: b3, else: b2
  b3():
    v9 = load v2
    v10 = load v5
    v12, v13, v14, v15 = call f31()
    v17, v18 = call slice_push_back(v9, v10, v12, v13, v14, v15)
    inc_rc v18
    store v17 at v2
    store v18 at v5
    v20 = add v1, u32 1
    jmp b1(v20)
  b2():
    v7 = load v2
    v8 = load v5
    inc_rc v8
    return v7, v8, u32 0
}
acir(inline) fn entries f27 {
  b0(v0: u32, v1: [u1, Field, Field, u1], v2: u32):
    inc_rc v1
    v4 = allocate
    store u32 0 at v4
    inc_rc []
    v7 = allocate
    store [] at v7
    inc_rc v1
    jmp b1(u32 0)
  b1(v3: u32):
    v8 = lt v3, v0
    jmpif v8 then: b3, else: b2
  b3():
    v42 = mul v3, u32 4
    v43 = lt v3, v0
    constrain v43 == u1 1 '"Index out of bounds"'
    v45 = array_get v1, index v42
    v47 = add v42, u32 1
    v48 = lt v3, v0
    constrain v48 == u1 1 '"Index out of bounds"'
    v49 = array_get v1, index v47
    v51 = add v42, u32 2
    v52 = lt v3, v0
    constrain v52 == u1 1 '"Index out of bounds"'
    v53 = array_get v1, index v51
    v55 = add v42, u32 3
    v56 = lt v3, v0
    constrain v56 == u1 1 '"Index out of bounds"'
    v57 = array_get v1, index v55
    v59 = call f28(v45, v49, v53, v57)
    jmpif v59 then: b4, else: b5
  b4():
    v61, v62, v63 = call f29(v45, v49, v53, v57)
    v65, v66 = call f14(v61, v62, v63)
    v67 = load v4
    v68 = load v7
    v70, v71 = call slice_push_back(v67, v68, v65, v66)
    inc_rc v71
    store v70 at v4
    store v71 at v7
    jmp b5()
  b5():
    v72 = add v3, u32 1
    jmp b1(v72)
  b2():
    inc_rc [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46]
    v36 = load v4
    v37 = load v7
    v38 = eq v36, v2
    constrain v36 == v2, data [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46], u32 0
    v39 = load v4
    v40 = load v7
    dec_rc v1
    return v39, v40
}
acir(inline) fn is_valid f28 {
  b0(v0: u1, v1: Field, v2: Field, v3: u1):
    v4 = not v3
    v6 = call f30(v0, v1, v2)
    v7 = mul v4, v6
    return v7
}
acir(inline) fn key_value f29 {
  b0(v0: u1, v1: Field, v2: Field, v3: u1):
    return v0, v1, v2
}
acir(inline) fn is_some f30 {
  b0(v0: u1, v1: Field, v2: Field):
    return v0
}
acir(inline) fn default f31 {
  b0():
    v1, v2, v3 = call f32()
    return v1, v2, v3, u1 0
}
acir(inline) fn none f32 {
  b0():
    return u1 0, Field 0, Field 0
}
acir(inline) fn default f33 {
  b0():
    call f35()
    v2, v3, v4 = call f34()
    return v2, v3, v4
}
acir(inline) fn with_hasher f34 {
  b0():
    v1, v2, v3, v4 = call f31()
    inc_rc [v1, v2, v3, v4]
    inc_rc [v1, v2, v3, v4]
    return u32 1, [v1, v2, v3, v4], u32 0
}
acir(inline) fn default f35 {
  b0():
    return 
}

After Removing Paired rc_inc & rc_decs:
brillig fn main f0 {
  b0(v0: [Field, Field; 6]):
    v2 = array_get v0, index u32 0
    v4 = array_get v0, index u32 1
    v5 = array_get v0, index u32 0
    v6 = array_get v0, index u32 1
    call f1(v2, v6)
    return 
}
brillig fn test_sequential f1 {
  b0(v0: Field, v1: Field):
    v3, v4, v5 = call f2()
    v6 = allocate
    store v3 at v6
    inc_rc v4
    v7 = allocate
    store v4 at v7
    v8 = allocate
    store v5 at v8
    v9 = load v6
    v10 = load v7
    v11 = load v8
    v13 = call f3(v9, v10, v11)
    constrain v13 == u1 1 '"New UHashMap should be empty."'
    call f4(v6, v7, v8, v0, v1)
    v16 = load v6
    v17 = load v7
    v18 = load v8
    v20 = call f5(v16, v17, v18)
    v22 = eq v20, u32 1
    constrain v20 == u32 1 '"UHashMap after one insert should have a length of 1 element."'
    return 
}
acir(inline) fn lambda f2 {
  b0():
    v1, v2, v3 = call f33()
    return v1, v2, v3
}
acir(inline) fn is_empty f3 {
  b0(v0: u32, v1: [u1, Field, Field, u1], v2: u32):
    v4 = eq v2, u32 0
    return v4
}
brillig fn insert f4 {
  b0(v0: &mut u32, v1: &mut [u1, Field, Field, u1], v2: &mut u32, v3: Field, v4: Field):
    v6 = load v1
    inc_rc v6
    call f6(v0, v1, v2)
    v8 = load v0
    v9 = load v1
    v10 = load v2
    v12 = call f7(v8, v9, v10, v3)
    v13 = load v0
    v14 = load v1
    v15 = load v2
    jmp b1(u32 0)
  b1(v5: u32):
    v17 = lt v5, v13
    jmpif v17 then: b2, else: b10
  b2():
    v18 = load v0
    v19 = load v1
    v20 = load v2
    v22 = call f8(v18, v19, v20, v12, v5)
    v23 = load v0
    v24 = load v1
    v25 = load v2
    v27 = mul v22, u32 4
    v28 = lt v22, v23
    constrain v28 == u1 1 '"Index out of bounds"'
    v30 = array_get v24, index v27
    v32 = add v27, u32 1
    v33 = lt v22, v23
    constrain v33 == u1 1 '"Index out of bounds"'
    v34 = array_get v24, index v32
    v36 = add v27, u32 2
    v37 = lt v22, v23
    constrain v37 == u1 1 '"Index out of bounds"'
    v38 = array_get v24, index v36
    v40 = add v27, u32 3
    v41 = lt v22, v23
    constrain v41 == u1 1 '"Index out of bounds"'
    v42 = array_get v24, index v40
    v43 = allocate
    store v30 at v43
    v44 = allocate
    store v34 at v44
    v45 = allocate
    store v38 at v45
    v46 = allocate
    store v42 at v46
    v47 = allocate
    store u1 0 at v47
    v49 = load v43
    v50 = load v44
    v51 = load v45
    v52 = load v46
    v54 = call f9(v49, v50, v51, v52)
    jmpif v54 then: b6, else: b3
  b6():
    store u1 1 at v47
    v64 = load v0
    v65 = load v1
    v66 = load v2
    v67 = load v0
    v68 = load v1
    v69 = load v2
    v70 = add v69, u32 1
    store v64 at v0
    store v65 at v1
    store v70 at v2
    jmp b7()
  b7():
    v71 = load v47
    jmpif v71 then: b9, else: b8
  b9():
    call f12(v43, v44, v45, v46, v3, v4)
    v74 = load v0
    v75 = load v1
    v76 = load v2
    v77 = load v43
    v78 = load v44
    v79 = load v45
    v80 = load v46
    v81 = mul v22, u32 4
    v82 = array_set v75, index v81, value v77
    v83 = add v81, u32 1
    v84 = array_set v82, index v83, value v78
    v85 = add v83, u32 1
    v86 = array_set v84, index v85, value v79
    v87 = add v85, u32 1
    v88 = array_set v86, index v87, value v80
    v89 = add v87, u32 1
    store v74 at v0
    store v88 at v1
    store v76 at v2
    jmp b10()
  b10():
    v90 = load v1
    dec_rc v90
    return 
  b8():
    v72 = add v5, u32 1
    jmp b1(v72)
  b3():
    v55 = load v43
    v56 = load v44
    v57 = load v45
    v58 = load v46
    v60, v61 = call f10(v55, v56, v57, v58)
    v63 = call f11(v60, v3)
    jmpif v63 then: b4, else: b5
  b4():
    store u1 1 at v47
    jmp b5()
  b5():
    jmp b7()
}
acir(inline) fn len f5 {
  b0(v0: u32, v1: [u1, Field, Field, u1], v2: u32):
    return v2
}
brillig fn try_resize f6 {
  b0(v0: &mut u32, v1: &mut [u1, Field, Field, u1], v2: &mut u32):
    v4 = load v1
    inc_rc v4
    v5 = load v0
    v6 = load v1
    v7 = load v2
    v9 = call f5(v5, v6, v7)
    v11 = add v9, u32 1
    v12 = load v0
    v13 = load v1
    v14 = load v2
    v16 = call f25(v12, v13, v14)
    v18 = div v16, u32 2
    v19 = lt v11, v18
    v20 = not v19
    jmpif v20 then: b1, else: b4
  b1():
    v21 = load v0
    v22 = load v1
    v23 = load v2
    v25 = call f25(v21, v22, v23)
    v26 = mul v25, u32 2
    v27 = load v0
    v28 = load v1
    v29 = load v2
    v31, v32, v33 = call f26(v26)
    v34 = allocate
    store v31 at v34
    inc_rc v32
    v35 = allocate
    store v32 at v35
    v36 = allocate
    store v33 at v36
    v37 = load v0
    v38 = load v1
    v39 = load v2
    v41, v42 = call f27(v37, v38, v39)
    inc_rc v42
    jmp b2(u32 0)
  b2(v3: u32):
    v44 = lt v3, v41
    jmpif v44 then: b5, else: b3
  b5():
    v49 = mul v3, u32 2
    v50 = lt v3, v41
    constrain v50 == u1 1 '"Index out of bounds"'
    v52 = array_get v42, index v49
    v53 = add v49, u32 1
    v54 = lt v3, v41
    constrain v54 == u1 1 '"Index out of bounds"'
    v55 = array_get v42, index v53
    call f4(v34, v35, v36, v52, v55)
    v57 = add v3, u32 1
    jmp b2(v57)
  b3():
    v45 = load v34
    v46 = load v35
    v47 = load v36
    inc_rc v46
    store v45 at v0
    store v46 at v1
    store v47 at v2
    jmp b4()
  b4():
    v48 = load v1
    dec_rc v48
    return 
}
acir(inline) fn hash f7 {
  b0(v0: u32, v1: [u1, Field, Field, u1], v2: u32, v3: Field):
    v5, v6 = call f16()
    v7 = allocate
    store v5 at v7
    inc_rc v6
    v8 = allocate
    store v6 at v8
    call f17(v3, v7, v8)
    v10 = load v7
    v11 = load v8
    v13 = call f18(v10, v11)
    v14 = truncate v13 to 32 bits, max_bit_size: 254
    v15 = cast v14 as u32
    return v15
}
acir(inline) fn quadratic_probe f8 {
  b0(v0: u32, v1: [u1, Field, Field, u1], v2: u32, v3: u32, v4: u32):
    v5 = mul v4, v4
    v6 = add v4, v5
    v8 = div v6, u32 2
    v9 = add v3, v8
    v10 = mod v9, v0
    return v10
}
acir(inline) fn is_available f9 {
  b0(v0: u1, v1: Field, v2: Field, v3: u1):
    v5 = call f15(v0, v1, v2)
    v6 = or v3, v5
    return v6
}
acir(inline) fn key_value_unchecked f10 {
  b0(v0: u1, v1: Field, v2: Field, v3: u1):
    v5, v6 = call f14(v0, v1, v2)
    return v5, v6
}
acir(inline) fn eq f11 {
  b0(v0: Field, v1: Field):
    v2 = eq v0, v1
    return v2
}
acir(inline) fn set f12 {
  b0(v0: &mut u1, v1: &mut Field, v2: &mut Field, v3: &mut u1, v4: Field, v5: Field):
    v6 = load v0
    v7 = load v1
    v8 = load v2
    v9 = load v3
    v11, v12, v13 = call f13(v4, v5)
    store v11 at v0
    store v12 at v1
    store v13 at v2
    store v9 at v3
    v14 = load v0
    v15 = load v1
    v16 = load v2
    v17 = load v3
    store v14 at v0
    store v15 at v1
    store v16 at v2
    store u1 0 at v3
    return 
}
acir(inline) fn some f13 {
  b0(v0: Field, v1: Field):
    return u1 1, v0, v1
}
acir(inline) fn unwrap_unchecked f14 {
  b0(v0: u1, v1: Field, v2: Field):
    return v1, v2
}
acir(inline) fn is_none f15 {
  b0(v0: u1, v1: Field, v2: Field):
    v3 = not v0
    return v3
}
acir(inline) fn build_hasher f16 {
  b0():
    v1, v2 = call f24()
    return v1, v2
}
acir(inline) fn hash f17 {
  b0(v0: Field, v1: &mut u32, v2: &mut [Field]):
    v3 = load v2
    inc_rc v3
    call f23(v1, v2, v0)
    v5 = load v2
    dec_rc v5
    return 
}
acir(inline) fn finish f18 {
  b0(v0: u32, v1: [Field]):
    v3 = cast v0 as Field
    v5 = mul v3, Field 2⁶⁴
    v7, v8, v9, v10 = call f19(v5)
    inc_rc v7
    v11 = allocate
    store v7 at v11
    inc_rc v8
    v12 = allocate
    store v8 at v12
    v13 = allocate
    store v9 at v13
    v14 = allocate
    store v10 at v14
    jmp b1(u32 0)
  b1(v2: u32):
    v16 = lt v2, v0
    jmpif v16 then: b3, else: b2
  b3():
    v19 = lt v2, v0
    constrain v19 == u1 1 '"Index out of bounds"'
    v21 = array_get v1, index v2
    call f20(v11, v12, v13, v14, v21)
    v24 = add v2, u32 1
    jmp b1(v24)
  b2():
    v18 = call f21(v11, v12, v13, v14)
    return v18
}
acir(inline) fn new f19 {
  b0(v0: Field):
    inc_rc [Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0]
    v4 = allocate
    store [Field 0, Field 0, Field 0] at v4
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    v5 = allocate
    store [Field 0, Field 0, Field 0, Field 0] at v5
    v6 = allocate
    store u32 0 at v6
    v8 = allocate
    store u1 0 at v8
    v10 = load v4
    v11 = load v5
    v12 = load v6
    v13 = load v8
    v15 = array_set v11, index u32 3, value v0
    store v10 at v4
    store v15 at v5
    store v12 at v6
    store v13 at v8
    v16 = load v4
    v17 = load v5
    v18 = load v6
    v19 = load v8
    return v16, v17, v18, v19
}
acir(inline) fn absorb f20 {
  b0(v0: &mut [Field; 3], v1: &mut [Field; 4], v2: &mut u32, v3: &mut u1, v4: Field):
    v5 = load v0
    inc_rc v5
    v6 = load v1
    inc_rc v6
    v7 = load v0
    v8 = load v1
    v9 = load v2
    v10 = load v3
    v11 = not v10
    constrain v10 == u1 0
    v13 = load v0
    v14 = load v1
    v15 = load v2
    v16 = load v3
    v18 = eq v15, u32 3
    jmpif v18 then: b2, else: b1
  b2():
    call f22(v0, v1, v2, v3)
    v40 = load v0
    v41 = load v1
    v42 = load v2
    v43 = load v3
    v45 = array_set v40, index u32 0, value v4
    store v45 at v0
    store v41 at v1
    store v42 at v2
    store v43 at v3
    v46 = load v0
    v47 = load v1
    v48 = load v2
    v49 = load v3
    store v46 at v0
    store v47 at v1
    store u32 1 at v2
    store v49 at v3
    jmp b3()
  b3():
    v50 = load v0
    dec_rc v50
    v51 = load v1
    dec_rc v51
    return 
  b1():
    v19 = load v0
    v20 = load v1
    v21 = load v2
    v22 = load v3
    v23 = load v0
    v24 = load v1
    v25 = load v2
    v26 = load v3
    v27 = array_set v19, index v25, value v4
    v29 = add v25, u32 1
    store v27 at v0
    store v20 at v1
    store v21 at v2
    store v22 at v3
    v30 = load v0
    v31 = load v1
    v32 = load v2
    v33 = load v3
    v34 = load v0
    v35 = load v1
    v36 = load v2
    v37 = load v3
    v38 = add v36, u32 1
    store v30 at v0
    store v31 at v1
    store v38 at v2
    store v33 at v3
    jmp b3()
}
acir(inline) fn squeeze f21 {
  b0(v0: &mut [Field; 3], v1: &mut [Field; 4], v2: &mut u32, v3: &mut u1):
    v4 = load v0
    inc_rc v4
    v5 = load v1
    inc_rc v5
    v6 = load v0
    v7 = load v1
    v8 = load v2
    v9 = load v3
    v10 = not v9
    constrain v9 == u1 0
    call f22(v0, v1, v2, v3)
    v13 = load v0
    v14 = load v1
    v15 = load v2
    v16 = load v3
    store v13 at v0
    store v14 at v1
    store v15 at v2
    store u1 1 at v3
    v18 = load v0
    v19 = load v1
    v20 = load v2
    v21 = load v3
    v23 = array_get v19, index u32 0
    v24 = load v0
    dec_rc v24
    v25 = load v1
    dec_rc v25
    return v23
}
acir(inline) fn perform_duplex f22 {
  b0(v0: &mut [Field; 3], v1: &mut [Field; 4], v2: &mut u32, v3: &mut u1):
    v5 = load v0
    inc_rc v5
    v6 = load v1
    inc_rc v6
    jmp b1(u32 0)
  b1(v4: u32):
    v9 = lt v4, u32 3
    jmpif v9 then: b3, else: b2
  b3():
    v23 = load v0
    v24 = load v1
    v25 = load v2
    v26 = load v3
    v27 = lt v4, v25
    jmpif v27 then: b4, else: b5
  b4():
    v28 = load v0
    v29 = load v1
    v30 = load v2
    v31 = load v3
    v32 = load v0
    v33 = load v1
    v34 = load v2
    v35 = load v3
    v36 = array_get v33, index v4
    v37 = load v0
    v38 = load v1
    v39 = load v2
    v40 = load v3
    v41 = array_get v37, index v4
    v42 = add v36, v41
    v43 = array_set v29, index v4, value v42
    v45 = add v4, u32 1
    store v28 at v0
    store v43 at v1
    store v30 at v2
    store v31 at v3
    jmp b5()
  b5():
    v46 = add v4, u32 1
    jmp b1(v46)
  b2():
    v10 = load v0
    v11 = load v1
    v12 = load v2
    v13 = load v3
    v14 = load v0
    v15 = load v1
    v16 = load v2
    v17 = load v3
    v20 = call poseidon2_permutation(v15, u32 4)
    inc_rc v20
    store v10 at v0
    store v20 at v1
    store v12 at v2
    store v13 at v3
    v21 = load v0
    dec_rc v21
    v22 = load v1
    dec_rc v22
    return 
}
acir(inline) fn write f23 {
  b0(v0: &mut u32, v1: &mut [Field], v2: Field):
    v3 = load v1
    inc_rc v3
    v4 = load v0
    v5 = load v1
    v6 = load v0
    v7 = load v1
    v9, v10 = call slice_push_back(v6, v7, v2)
    inc_rc v10
    store v9 at v0
    store v10 at v1
    v11 = load v1
    dec_rc v11
    return 
}
acir(inline) fn default f24 {
  b0():
    inc_rc []
    return u32 0, []
}
acir(inline) fn capacity f25 {
  b0(v0: u32, v1: [u1, Field, Field, u1], v2: u32):
    return v0
}
acir(inline) fn with_hasher_and_capacity f26 {
  b0(v0: u32):
    v2 = allocate
    store u32 0 at v2
    inc_rc []
    v5 = allocate
    store [] at v5
    jmp b1(u32 0)
  b1(v1: u32):
    v6 = lt v1, v0
    jmpif v6 then: b3, else: b2
  b3():
    v9 = load v2
    v10 = load v5
    v12, v13, v14, v15 = call f31()
    v17, v18 = call slice_push_back(v9, v10, v12, v13, v14, v15)
    inc_rc v18
    store v17 at v2
    store v18 at v5
    v20 = add v1, u32 1
    jmp b1(v20)
  b2():
    v7 = load v2
    v8 = load v5
    inc_rc v8
    return v7, v8, u32 0
}
acir(inline) fn entries f27 {
  b0(v0: u32, v1: [u1, Field, Field, u1], v2: u32):
    v4 = allocate
    store u32 0 at v4
    inc_rc []
    v7 = allocate
    store [] at v7
    inc_rc v1
    jmp b1(u32 0)
  b1(v3: u32):
    v8 = lt v3, v0
    jmpif v8 then: b3, else: b2
  b3():
    v42 = mul v3, u32 4
    v43 = lt v3, v0
    constrain v43 == u1 1 '"Index out of bounds"'
    v45 = array_get v1, index v42
    v47 = add v42, u32 1
    v48 = lt v3, v0
    constrain v48 == u1 1 '"Index out of bounds"'
    v49 = array_get v1, index v47
    v51 = add v42, u32 2
    v52 = lt v3, v0
    constrain v52 == u1 1 '"Index out of bounds"'
    v53 = array_get v1, index v51
    v55 = add v42, u32 3
    v56 = lt v3, v0
    constrain v56 == u1 1 '"Index out of bounds"'
    v57 = array_get v1, index v55
    v59 = call f28(v45, v49, v53, v57)
    jmpif v59 then: b4, else: b5
  b4():
    v61, v62, v63 = call f29(v45, v49, v53, v57)
    v65, v66 = call f14(v61, v62, v63)
    v67 = load v4
    v68 = load v7
    v70, v71 = call slice_push_back(v67, v68, v65, v66)
    inc_rc v71
    store v70 at v4
    store v71 at v7
    jmp b5()
  b5():
    v72 = add v3, u32 1
    jmp b1(v72)
  b2():
    inc_rc [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46]
    v36 = load v4
    v37 = load v7
    v38 = eq v36, v2
    constrain v36 == v2, data [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46], u32 0
    v39 = load v4
    v40 = load v7
    return v39, v40
}
acir(inline) fn is_valid f28 {
  b0(v0: u1, v1: Field, v2: Field, v3: u1):
    v4 = not v3
    v6 = call f30(v0, v1, v2)
    v7 = mul v4, v6
    return v7
}
acir(inline) fn key_value f29 {
  b0(v0: u1, v1: Field, v2: Field, v3: u1):
    return v0, v1, v2
}
acir(inline) fn is_some f30 {
  b0(v0: u1, v1: Field, v2: Field):
    return v0
}
acir(inline) fn default f31 {
  b0():
    v1, v2, v3 = call f32()
    return v1, v2, v3, u1 0
}
acir(inline) fn none f32 {
  b0():
    return u1 0, Field 0, Field 0
}
acir(inline) fn default f33 {
  b0():
    call f35()
    v2, v3, v4 = call f34()
    return v2, v3, v4
}
acir(inline) fn with_hasher f34 {
  b0():
    v1, v2, v3, v4 = call f31()
    inc_rc [v1, v2, v3, v4]
    inc_rc [v1, v2, v3, v4]
    return u32 1, [v1, v2, v3, v4], u32 0
}
acir(inline) fn default f35 {
  b0():
    return 
}

After Runtime Separation:
brillig fn main f0 {
  b0(v0: [Field, Field; 6]):
    v2 = array_get v0, index u32 0
    v4 = array_get v0, index u32 1
    v5 = array_get v0, index u32 0
    v6 = array_get v0, index u32 1
    call f1(v2, v6)
    return 
}
brillig fn test_sequential f1 {
  b0(v0: Field, v1: Field):
    v3, v4, v5 = call f4()
    v6 = allocate
    store v3 at v6
    inc_rc v4
    v7 = allocate
    store v4 at v7
    v8 = allocate
    store v5 at v8
    v9 = load v6
    v10 = load v7
    v11 = load v8
    v13 = call f5(v9, v10, v11)
    constrain v13 == u1 1 '"New UHashMap should be empty."'
    call f2(v6, v7, v8, v0, v1)
    v16 = load v6
    v17 = load v7
    v18 = load v8
    v20 = call f6(v16, v17, v18)
    v22 = eq v20, u32 1
    constrain v20 == u32 1 '"UHashMap after one insert should have a length of 1 element."'
    return 
}
brillig fn insert f2 {
  b0(v0: &mut u32, v1: &mut [u1, Field, Field, u1], v2: &mut u32, v3: Field, v4: Field):
    v6 = load v1
    inc_rc v6
    call f3(v0, v1, v2)
    v8 = load v0
    v9 = load v1
    v10 = load v2
    v12 = call f7(v8, v9, v10, v3)
    v13 = load v0
    v14 = load v1
    v15 = load v2
    jmp b1(u32 0)
  b1(v5: u32):
    v17 = lt v5, v13
    jmpif v17 then: b2, else: b10
  b2():
    v18 = load v0
    v19 = load v1
    v20 = load v2
    v22 = call f8(v18, v19, v20, v12, v5)
    v23 = load v0
    v24 = load v1
    v25 = load v2
    v27 = mul v22, u32 4
    v28 = lt v22, v23
    constrain v28 == u1 1 '"Index out of bounds"'
    v30 = array_get v24, index v27
    v32 = add v27, u32 1
    v33 = lt v22, v23
    constrain v33 == u1 1 '"Index out of bounds"'
    v34 = array_get v24, index v32
    v36 = add v27, u32 2
    v37 = lt v22, v23
    constrain v37 == u1 1 '"Index out of bounds"'
    v38 = array_get v24, index v36
    v40 = add v27, u32 3
    v41 = lt v22, v23
    constrain v41 == u1 1 '"Index out of bounds"'
    v42 = array_get v24, index v40
    v43 = allocate
    store v30 at v43
    v44 = allocate
    store v34 at v44
    v45 = allocate
    store v38 at v45
    v46 = allocate
    store v42 at v46
    v47 = allocate
    store u1 0 at v47
    v49 = load v43
    v50 = load v44
    v51 = load v45
    v52 = load v46
    v54 = call f9(v49, v50, v51, v52)
    jmpif v54 then: b6, else: b3
  b6():
    store u1 1 at v47
    v64 = load v0
    v65 = load v1
    v66 = load v2
    v67 = load v0
    v68 = load v1
    v69 = load v2
    v70 = add v69, u32 1
    store v64 at v0
    store v65 at v1
    store v70 at v2
    jmp b7()
  b7():
    v71 = load v47
    jmpif v71 then: b9, else: b8
  b9():
    call f12(v43, v44, v45, v46, v3, v4)
    v74 = load v0
    v75 = load v1
    v76 = load v2
    v77 = load v43
    v78 = load v44
    v79 = load v45
    v80 = load v46
    v81 = mul v22, u32 4
    v82 = array_set v75, index v81, value v77
    v83 = add v81, u32 1
    v84 = array_set v82, index v83, value v78
    v85 = add v83, u32 1
    v86 = array_set v84, index v85, value v79
    v87 = add v85, u32 1
    v88 = array_set v86, index v87, value v80
    v89 = add v87, u32 1
    store v74 at v0
    store v88 at v1
    store v76 at v2
    jmp b10()
  b10():
    v90 = load v1
    dec_rc v90
    return 
  b8():
    v72 = add v5, u32 1
    jmp b1(v72)
  b3():
    v55 = load v43
    v56 = load v44
    v57 = load v45
    v58 = load v46
    v60, v61 = call f10(v55, v56, v57, v58)
    v63 = call f11(v60, v3)
    jmpif v63 then: b4, else: b5
  b4():
    store u1 1 at v47
    jmp b5()
  b5():
    jmp b7()
}
brillig fn try_resize f3 {
  b0(v0: &mut u32, v1: &mut [u1, Field, Field, u1], v2: &mut u32):
    v4 = load v1
    inc_rc v4
    v5 = load v0
    v6 = load v1
    v7 = load v2
    v9 = call f6(v5, v6, v7)
    v11 = add v9, u32 1
    v12 = load v0
    v13 = load v1
    v14 = load v2
    v16 = call f25(v12, v13, v14)
    v18 = div v16, u32 2
    v19 = lt v11, v18
    v20 = not v19
    jmpif v20 then: b1, else: b4
  b1():
    v21 = load v0
    v22 = load v1
    v23 = load v2
    v25 = call f25(v21, v22, v23)
    v26 = mul v25, u32 2
    v27 = load v0
    v28 = load v1
    v29 = load v2
    v31, v32, v33 = call f26(v26)
    v34 = allocate
    store v31 at v34
    inc_rc v32
    v35 = allocate
    store v32 at v35
    v36 = allocate
    store v33 at v36
    v37 = load v0
    v38 = load v1
    v39 = load v2
    v41, v42 = call f27(v37, v38, v39)
    inc_rc v42
    jmp b2(u32 0)
  b2(v3: u32):
    v44 = lt v3, v41
    jmpif v44 then: b5, else: b3
  b5():
    v49 = mul v3, u32 2
    v50 = lt v3, v41
    constrain v50 == u1 1 '"Index out of bounds"'
    v52 = array_get v42, index v49
    v53 = add v49, u32 1
    v54 = lt v3, v41
    constrain v54 == u1 1 '"Index out of bounds"'
    v55 = array_get v42, index v53
    call f2(v34, v35, v36, v52, v55)
    v57 = add v3, u32 1
    jmp b2(v57)
  b3():
    v45 = load v34
    v46 = load v35
    v47 = load v36
    inc_rc v46
    store v45 at v0
    store v46 at v1
    store v47 at v2
    jmp b4()
  b4():
    v48 = load v1
    dec_rc v48
    return 
}
brillig fn lambda f4 {
  b0():
    v1, v2, v3 = call f33()
    return v1, v2, v3
}
brillig fn is_empty f5 {
  b0(v0: u32, v1: [u1, Field, Field, u1], v2: u32):
    v4 = eq v2, u32 0
    return v4
}
brillig fn len f6 {
  b0(v0: u32, v1: [u1, Field, Field, u1], v2: u32):
    return v2
}
brillig fn hash f7 {
  b0(v0: u32, v1: [u1, Field, Field, u1], v2: u32, v3: Field):
    v5, v6 = call f16()
    v7 = allocate
    store v5 at v7
    inc_rc v6
    v8 = allocate
    store v6 at v8
    call f17(v3, v7, v8)
    v10 = load v7
    v11 = load v8
    v13 = call f18(v10, v11)
    v14 = truncate v13 to 32 bits, max_bit_size: 254
    v15 = cast v14 as u32
    return v15
}
brillig fn quadratic_probe f8 {
  b0(v0: u32, v1: [u1, Field, Field, u1], v2: u32, v3: u32, v4: u32):
    v5 = mul v4, v4
    v6 = add v4, v5
    v8 = div v6, u32 2
    v9 = add v3, v8
    v10 = mod v9, v0
    return v10
}
brillig fn is_available f9 {
  b0(v0: u1, v1: Field, v2: Field, v3: u1):
    v5 = call f15(v0, v1, v2)
    v6 = or v3, v5
    return v6
}
brillig fn key_value_unchecked f10 {
  b0(v0: u1, v1: Field, v2: Field, v3: u1):
    v5, v6 = call f14(v0, v1, v2)
    return v5, v6
}
brillig fn eq f11 {
  b0(v0: Field, v1: Field):
    v2 = eq v0, v1
    return v2
}
brillig fn set f12 {
  b0(v0: &mut u1, v1: &mut Field, v2: &mut Field, v3: &mut u1, v4: Field, v5: Field):
    v6 = load v0
    v7 = load v1
    v8 = load v2
    v9 = load v3
    v11, v12, v13 = call f13(v4, v5)
    store v11 at v0
    store v12 at v1
    store v13 at v2
    store v9 at v3
    v14 = load v0
    v15 = load v1
    v16 = load v2
    v17 = load v3
    store v14 at v0
    store v15 at v1
    store v16 at v2
    store u1 0 at v3
    return 
}
brillig fn some f13 {
  b0(v0: Field, v1: Field):
    return u1 1, v0, v1
}
brillig fn unwrap_unchecked f14 {
  b0(v0: u1, v1: Field, v2: Field):
    return v1, v2
}
brillig fn is_none f15 {
  b0(v0: u1, v1: Field, v2: Field):
    v3 = not v0
    return v3
}
brillig fn build_hasher f16 {
  b0():
    v1, v2 = call f24()
    return v1, v2
}
brillig fn hash f17 {
  b0(v0: Field, v1: &mut u32, v2: &mut [Field]):
    v3 = load v2
    inc_rc v3
    call f23(v1, v2, v0)
    v5 = load v2
    dec_rc v5
    return 
}
brillig fn finish f18 {
  b0(v0: u32, v1: [Field]):
    v3 = cast v0 as Field
    v5 = mul v3, Field 2⁶⁴
    v7, v8, v9, v10 = call f19(v5)
    inc_rc v7
    v11 = allocate
    store v7 at v11
    inc_rc v8
    v12 = allocate
    store v8 at v12
    v13 = allocate
    store v9 at v13
    v14 = allocate
    store v10 at v14
    jmp b1(u32 0)
  b1(v2: u32):
    v16 = lt v2, v0
    jmpif v16 then: b3, else: b2
  b3():
    v19 = lt v2, v0
    constrain v19 == u1 1 '"Index out of bounds"'
    v21 = array_get v1, index v2
    call f20(v11, v12, v13, v14, v21)
    v24 = add v2, u32 1
    jmp b1(v24)
  b2():
    v18 = call f21(v11, v12, v13, v14)
    return v18
}
brillig fn new f19 {
  b0(v0: Field):
    inc_rc [Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0]
    v4 = allocate
    store [Field 0, Field 0, Field 0] at v4
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    v5 = allocate
    store [Field 0, Field 0, Field 0, Field 0] at v5
    v6 = allocate
    store u32 0 at v6
    v8 = allocate
    store u1 0 at v8
    v10 = load v4
    v11 = load v5
    v12 = load v6
    v13 = load v8
    v15 = array_set v11, index u32 3, value v0
    store v10 at v4
    store v15 at v5
    store v12 at v6
    store v13 at v8
    v16 = load v4
    v17 = load v5
    v18 = load v6
    v19 = load v8
    return v16, v17, v18, v19
}
brillig fn absorb f20 {
  b0(v0: &mut [Field; 3], v1: &mut [Field; 4], v2: &mut u32, v3: &mut u1, v4: Field):
    v5 = load v0
    inc_rc v5
    v6 = load v1
    inc_rc v6
    v7 = load v0
    v8 = load v1
    v9 = load v2
    v10 = load v3
    v11 = not v10
    constrain v10 == u1 0
    v13 = load v0
    v14 = load v1
    v15 = load v2
    v16 = load v3
    v18 = eq v15, u32 3
    jmpif v18 then: b2, else: b1
  b2():
    call f22(v0, v1, v2, v3)
    v40 = load v0
    v41 = load v1
    v42 = load v2
    v43 = load v3
    v45 = array_set v40, index u32 0, value v4
    store v45 at v0
    store v41 at v1
    store v42 at v2
    store v43 at v3
    v46 = load v0
    v47 = load v1
    v48 = load v2
    v49 = load v3
    store v46 at v0
    store v47 at v1
    store u32 1 at v2
    store v49 at v3
    jmp b3()
  b3():
    v50 = load v0
    dec_rc v50
    v51 = load v1
    dec_rc v51
    return 
  b1():
    v19 = load v0
    v20 = load v1
    v21 = load v2
    v22 = load v3
    v23 = load v0
    v24 = load v1
    v25 = load v2
    v26 = load v3
    v27 = array_set v19, index v25, value v4
    v29 = add v25, u32 1
    store v27 at v0
    store v20 at v1
    store v21 at v2
    store v22 at v3
    v30 = load v0
    v31 = load v1
    v32 = load v2
    v33 = load v3
    v34 = load v0
    v35 = load v1
    v36 = load v2
    v37 = load v3
    v38 = add v36, u32 1
    store v30 at v0
    store v31 at v1
    store v38 at v2
    store v33 at v3
    jmp b3()
}
brillig fn squeeze f21 {
  b0(v0: &mut [Field; 3], v1: &mut [Field; 4], v2: &mut u32, v3: &mut u1):
    v4 = load v0
    inc_rc v4
    v5 = load v1
    inc_rc v5
    v6 = load v0
    v7 = load v1
    v8 = load v2
    v9 = load v3
    v10 = not v9
    constrain v9 == u1 0
    call f22(v0, v1, v2, v3)
    v13 = load v0
    v14 = load v1
    v15 = load v2
    v16 = load v3
    store v13 at v0
    store v14 at v1
    store v15 at v2
    store u1 1 at v3
    v18 = load v0
    v19 = load v1
    v20 = load v2
    v21 = load v3
    v23 = array_get v19, index u32 0
    v24 = load v0
    dec_rc v24
    v25 = load v1
    dec_rc v25
    return v23
}
brillig fn perform_duplex f22 {
  b0(v0: &mut [Field; 3], v1: &mut [Field; 4], v2: &mut u32, v3: &mut u1):
    v5 = load v0
    inc_rc v5
    v6 = load v1
    inc_rc v6
    jmp b1(u32 0)
  b1(v4: u32):
    v9 = lt v4, u32 3
    jmpif v9 then: b3, else: b2
  b3():
    v23 = load v0
    v24 = load v1
    v25 = load v2
    v26 = load v3
    v27 = lt v4, v25
    jmpif v27 then: b4, else: b5
  b4():
    v28 = load v0
    v29 = load v1
    v30 = load v2
    v31 = load v3
    v32 = load v0
    v33 = load v1
    v34 = load v2
    v35 = load v3
    v36 = array_get v33, index v4
    v37 = load v0
    v38 = load v1
    v39 = load v2
    v40 = load v3
    v41 = array_get v37, index v4
    v42 = add v36, v41
    v43 = array_set v29, index v4, value v42
    v45 = add v4, u32 1
    store v28 at v0
    store v43 at v1
    store v30 at v2
    store v31 at v3
    jmp b5()
  b5():
    v46 = add v4, u32 1
    jmp b1(v46)
  b2():
    v10 = load v0
    v11 = load v1
    v12 = load v2
    v13 = load v3
    v14 = load v0
    v15 = load v1
    v16 = load v2
    v17 = load v3
    v20 = call poseidon2_permutation(v15, u32 4)
    inc_rc v20
    store v10 at v0
    store v20 at v1
    store v12 at v2
    store v13 at v3
    v21 = load v0
    dec_rc v21
    v22 = load v1
    dec_rc v22
    return 
}
brillig fn write f23 {
  b0(v0: &mut u32, v1: &mut [Field], v2: Field):
    v3 = load v1
    inc_rc v3
    v4 = load v0
    v5 = load v1
    v6 = load v0
    v7 = load v1
    v9, v10 = call slice_push_back(v6, v7, v2)
    inc_rc v10
    store v9 at v0
    store v10 at v1
    v11 = load v1
    dec_rc v11
    return 
}
brillig fn default f24 {
  b0():
    inc_rc []
    return u32 0, []
}
brillig fn capacity f25 {
  b0(v0: u32, v1: [u1, Field, Field, u1], v2: u32):
    return v0
}
brillig fn with_hasher_and_capacity f26 {
  b0(v0: u32):
    v2 = allocate
    store u32 0 at v2
    inc_rc []
    v5 = allocate
    store [] at v5
    jmp b1(u32 0)
  b1(v1: u32):
    v6 = lt v1, v0
    jmpif v6 then: b3, else: b2
  b3():
    v9 = load v2
    v10 = load v5
    v12, v13, v14, v15 = call f31()
    v17, v18 = call slice_push_back(v9, v10, v12, v13, v14, v15)
    inc_rc v18
    store v17 at v2
    store v18 at v5
    v20 = add v1, u32 1
    jmp b1(v20)
  b2():
    v7 = load v2
    v8 = load v5
    inc_rc v8
    return v7, v8, u32 0
}
brillig fn entries f27 {
  b0(v0: u32, v1: [u1, Field, Field, u1], v2: u32):
    v4 = allocate
    store u32 0 at v4
    inc_rc []
    v7 = allocate
    store [] at v7
    inc_rc v1
    jmp b1(u32 0)
  b1(v3: u32):
    v8 = lt v3, v0
    jmpif v8 then: b3, else: b2
  b3():
    v42 = mul v3, u32 4
    v43 = lt v3, v0
    constrain v43 == u1 1 '"Index out of bounds"'
    v45 = array_get v1, index v42
    v47 = add v42, u32 1
    v48 = lt v3, v0
    constrain v48 == u1 1 '"Index out of bounds"'
    v49 = array_get v1, index v47
    v51 = add v42, u32 2
    v52 = lt v3, v0
    constrain v52 == u1 1 '"Index out of bounds"'
    v53 = array_get v1, index v51
    v55 = add v42, u32 3
    v56 = lt v3, v0
    constrain v56 == u1 1 '"Index out of bounds"'
    v57 = array_get v1, index v55
    v59 = call f28(v45, v49, v53, v57)
    jmpif v59 then: b4, else: b5
  b4():
    v61, v62, v63 = call f29(v45, v49, v53, v57)
    v65, v66 = call f14(v61, v62, v63)
    v67 = load v4
    v68 = load v7
    v70, v71 = call slice_push_back(v67, v68, v65, v66)
    inc_rc v71
    store v70 at v4
    store v71 at v7
    jmp b5()
  b5():
    v72 = add v3, u32 1
    jmp b1(v72)
  b2():
    inc_rc [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46]
    v36 = load v4
    v37 = load v7
    v38 = eq v36, v2
    constrain v36 == v2, data [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46], u32 0
    v39 = load v4
    v40 = load v7
    return v39, v40
}
brillig fn is_valid f28 {
  b0(v0: u1, v1: Field, v2: Field, v3: u1):
    v4 = not v3
    v6 = call f30(v0, v1, v2)
    v7 = mul v4, v6
    return v7
}
brillig fn key_value f29 {
  b0(v0: u1, v1: Field, v2: Field, v3: u1):
    return v0, v1, v2
}
brillig fn is_some f30 {
  b0(v0: u1, v1: Field, v2: Field):
    return v0
}
brillig fn default f31 {
  b0():
    v1, v2, v3 = call f32()
    return v1, v2, v3, u1 0
}
brillig fn none f32 {
  b0():
    return u1 0, Field 0, Field 0
}
brillig fn default f33 {
  b0():
    call f35()
    v2, v3, v4 = call f34()
    return v2, v3, v4
}
brillig fn with_hasher f34 {
  b0():
    v1, v2, v3, v4 = call f31()
    inc_rc [v1, v2, v3, v4]
    inc_rc [v1, v2, v3, v4]
    return u32 1, [v1, v2, v3, v4], u32 0
}
brillig fn default f35 {
  b0():
    return 
}

After Resolving IsUnconstrained:
brillig fn main f0 {
  b0(v0: [Field, Field; 6]):
    v2 = array_get v0, index u32 0
    v4 = array_get v0, index u32 1
    v5 = array_get v0, index u32 0
    v6 = array_get v0, index u32 1
    call f1(v2, v6)
    return 
}
brillig fn test_sequential f1 {
  b0(v0: Field, v1: Field):
    v3, v4, v5 = call f4()
    v6 = allocate
    store v3 at v6
    inc_rc v4
    v7 = allocate
    store v4 at v7
    v8 = allocate
    store v5 at v8
    v9 = load v6
    v10 = load v7
    v11 = load v8
    v13 = call f5(v9, v10, v11)
    constrain v13 == u1 1 '"New UHashMap should be empty."'
    call f2(v6, v7, v8, v0, v1)
    v16 = load v6
    v17 = load v7
    v18 = load v8
    v20 = call f6(v16, v17, v18)
    v22 = eq v20, u32 1
    constrain v20 == u32 1 '"UHashMap after one insert should have a length of 1 element."'
    return 
}
brillig fn insert f2 {
  b0(v0: &mut u32, v1: &mut [u1, Field, Field, u1], v2: &mut u32, v3: Field, v4: Field):
    v6 = load v1
    inc_rc v6
    call f3(v0, v1, v2)
    v8 = load v0
    v9 = load v1
    v10 = load v2
    v12 = call f7(v8, v9, v10, v3)
    v13 = load v0
    v14 = load v1
    v15 = load v2
    jmp b1(u32 0)
  b1(v5: u32):
    v17 = lt v5, v13
    jmpif v17 then: b2, else: b10
  b2():
    v18 = load v0
    v19 = load v1
    v20 = load v2
    v22 = call f8(v18, v19, v20, v12, v5)
    v23 = load v0
    v24 = load v1
    v25 = load v2
    v27 = mul v22, u32 4
    v28 = lt v22, v23
    constrain v28 == u1 1 '"Index out of bounds"'
    v30 = array_get v24, index v27
    v32 = add v27, u32 1
    v33 = lt v22, v23
    constrain v33 == u1 1 '"Index out of bounds"'
    v34 = array_get v24, index v32
    v36 = add v27, u32 2
    v37 = lt v22, v23
    constrain v37 == u1 1 '"Index out of bounds"'
    v38 = array_get v24, index v36
    v40 = add v27, u32 3
    v41 = lt v22, v23
    constrain v41 == u1 1 '"Index out of bounds"'
    v42 = array_get v24, index v40
    v43 = allocate
    store v30 at v43
    v44 = allocate
    store v34 at v44
    v45 = allocate
    store v38 at v45
    v46 = allocate
    store v42 at v46
    v47 = allocate
    store u1 0 at v47
    v49 = load v43
    v50 = load v44
    v51 = load v45
    v52 = load v46
    v54 = call f9(v49, v50, v51, v52)
    jmpif v54 then: b6, else: b3
  b6():
    store u1 1 at v47
    v64 = load v0
    v65 = load v1
    v66 = load v2
    v67 = load v0
    v68 = load v1
    v69 = load v2
    v70 = add v69, u32 1
    store v64 at v0
    store v65 at v1
    store v70 at v2
    jmp b7()
  b7():
    v71 = load v47
    jmpif v71 then: b9, else: b8
  b9():
    call f12(v43, v44, v45, v46, v3, v4)
    v74 = load v0
    v75 = load v1
    v76 = load v2
    v77 = load v43
    v78 = load v44
    v79 = load v45
    v80 = load v46
    v81 = mul v22, u32 4
    v82 = array_set v75, index v81, value v77
    v83 = add v81, u32 1
    v84 = array_set v82, index v83, value v78
    v85 = add v83, u32 1
    v86 = array_set v84, index v85, value v79
    v87 = add v85, u32 1
    v88 = array_set v86, index v87, value v80
    v89 = add v87, u32 1
    store v74 at v0
    store v88 at v1
    store v76 at v2
    jmp b10()
  b10():
    v90 = load v1
    dec_rc v90
    return 
  b8():
    v72 = add v5, u32 1
    jmp b1(v72)
  b3():
    v55 = load v43
    v56 = load v44
    v57 = load v45
    v58 = load v46
    v60, v61 = call f10(v55, v56, v57, v58)
    v63 = call f11(v60, v3)
    jmpif v63 then: b4, else: b5
  b4():
    store u1 1 at v47
    jmp b5()
  b5():
    jmp b7()
}
brillig fn try_resize f3 {
  b0(v0: &mut u32, v1: &mut [u1, Field, Field, u1], v2: &mut u32):
    v4 = load v1
    inc_rc v4
    v5 = load v0
    v6 = load v1
    v7 = load v2
    v9 = call f6(v5, v6, v7)
    v11 = add v9, u32 1
    v12 = load v0
    v13 = load v1
    v14 = load v2
    v16 = call f25(v12, v13, v14)
    v18 = div v16, u32 2
    v19 = lt v11, v18
    v20 = not v19
    jmpif v20 then: b1, else: b4
  b1():
    v21 = load v0
    v22 = load v1
    v23 = load v2
    v25 = call f25(v21, v22, v23)
    v26 = mul v25, u32 2
    v27 = load v0
    v28 = load v1
    v29 = load v2
    v31, v32, v33 = call f26(v26)
    v34 = allocate
    store v31 at v34
    inc_rc v32
    v35 = allocate
    store v32 at v35
    v36 = allocate
    store v33 at v36
    v37 = load v0
    v38 = load v1
    v39 = load v2
    v41, v42 = call f27(v37, v38, v39)
    inc_rc v42
    jmp b2(u32 0)
  b2(v3: u32):
    v44 = lt v3, v41
    jmpif v44 then: b5, else: b3
  b5():
    v49 = mul v3, u32 2
    v50 = lt v3, v41
    constrain v50 == u1 1 '"Index out of bounds"'
    v52 = array_get v42, index v49
    v53 = add v49, u32 1
    v54 = lt v3, v41
    constrain v54 == u1 1 '"Index out of bounds"'
    v55 = array_get v42, index v53
    call f2(v34, v35, v36, v52, v55)
    v57 = add v3, u32 1
    jmp b2(v57)
  b3():
    v45 = load v34
    v46 = load v35
    v47 = load v36
    inc_rc v46
    store v45 at v0
    store v46 at v1
    store v47 at v2
    jmp b4()
  b4():
    v48 = load v1
    dec_rc v48
    return 
}
brillig fn lambda f4 {
  b0():
    v1, v2, v3 = call f33()
    return v1, v2, v3
}
brillig fn is_empty f5 {
  b0(v0: u32, v1: [u1, Field, Field, u1], v2: u32):
    v4 = eq v2, u32 0
    return v4
}
brillig fn len f6 {
  b0(v0: u32, v1: [u1, Field, Field, u1], v2: u32):
    return v2
}
brillig fn hash f7 {
  b0(v0: u32, v1: [u1, Field, Field, u1], v2: u32, v3: Field):
    v5, v6 = call f16()
    v7 = allocate
    store v5 at v7
    inc_rc v6
    v8 = allocate
    store v6 at v8
    call f17(v3, v7, v8)
    v10 = load v7
    v11 = load v8
    v13 = call f18(v10, v11)
    v14 = truncate v13 to 32 bits, max_bit_size: 254
    v15 = cast v14 as u32
    return v15
}
brillig fn quadratic_probe f8 {
  b0(v0: u32, v1: [u1, Field, Field, u1], v2: u32, v3: u32, v4: u32):
    v5 = mul v4, v4
    v6 = add v4, v5
    v8 = div v6, u32 2
    v9 = add v3, v8
    v10 = mod v9, v0
    return v10
}
brillig fn is_available f9 {
  b0(v0: u1, v1: Field, v2: Field, v3: u1):
    v5 = call f15(v0, v1, v2)
    v6 = or v3, v5
    return v6
}
brillig fn key_value_unchecked f10 {
  b0(v0: u1, v1: Field, v2: Field, v3: u1):
    v5, v6 = call f14(v0, v1, v2)
    return v5, v6
}
brillig fn eq f11 {
  b0(v0: Field, v1: Field):
    v2 = eq v0, v1
    return v2
}
brillig fn set f12 {
  b0(v0: &mut u1, v1: &mut Field, v2: &mut Field, v3: &mut u1, v4: Field, v5: Field):
    v6 = load v0
    v7 = load v1
    v8 = load v2
    v9 = load v3
    v11, v12, v13 = call f13(v4, v5)
    store v11 at v0
    store v12 at v1
    store v13 at v2
    store v9 at v3
    v14 = load v0
    v15 = load v1
    v16 = load v2
    v17 = load v3
    store v14 at v0
    store v15 at v1
    store v16 at v2
    store u1 0 at v3
    return 
}
brillig fn some f13 {
  b0(v0: Field, v1: Field):
    return u1 1, v0, v1
}
brillig fn unwrap_unchecked f14 {
  b0(v0: u1, v1: Field, v2: Field):
    return v1, v2
}
brillig fn is_none f15 {
  b0(v0: u1, v1: Field, v2: Field):
    v3 = not v0
    return v3
}
brillig fn build_hasher f16 {
  b0():
    v1, v2 = call f24()
    return v1, v2
}
brillig fn hash f17 {
  b0(v0: Field, v1: &mut u32, v2: &mut [Field]):
    v3 = load v2
    inc_rc v3
    call f23(v1, v2, v0)
    v5 = load v2
    dec_rc v5
    return 
}
brillig fn finish f18 {
  b0(v0: u32, v1: [Field]):
    v3 = cast v0 as Field
    v5 = mul v3, Field 2⁶⁴
    v7, v8, v9, v10 = call f19(v5)
    inc_rc v7
    v11 = allocate
    store v7 at v11
    inc_rc v8
    v12 = allocate
    store v8 at v12
    v13 = allocate
    store v9 at v13
    v14 = allocate
    store v10 at v14
    jmp b1(u32 0)
  b1(v2: u32):
    v16 = lt v2, v0
    jmpif v16 then: b3, else: b2
  b3():
    v19 = lt v2, v0
    constrain v19 == u1 1 '"Index out of bounds"'
    v21 = array_get v1, index v2
    call f20(v11, v12, v13, v14, v21)
    v24 = add v2, u32 1
    jmp b1(v24)
  b2():
    v18 = call f21(v11, v12, v13, v14)
    return v18
}
brillig fn new f19 {
  b0(v0: Field):
    inc_rc [Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0]
    v4 = allocate
    store [Field 0, Field 0, Field 0] at v4
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    v5 = allocate
    store [Field 0, Field 0, Field 0, Field 0] at v5
    v6 = allocate
    store u32 0 at v6
    v8 = allocate
    store u1 0 at v8
    v10 = load v4
    v11 = load v5
    v12 = load v6
    v13 = load v8
    v15 = array_set v11, index u32 3, value v0
    store v10 at v4
    store v15 at v5
    store v12 at v6
    store v13 at v8
    v16 = load v4
    v17 = load v5
    v18 = load v6
    v19 = load v8
    return v16, v17, v18, v19
}
brillig fn absorb f20 {
  b0(v0: &mut [Field; 3], v1: &mut [Field; 4], v2: &mut u32, v3: &mut u1, v4: Field):
    v5 = load v0
    inc_rc v5
    v6 = load v1
    inc_rc v6
    v7 = load v0
    v8 = load v1
    v9 = load v2
    v10 = load v3
    v11 = not v10
    constrain v10 == u1 0
    v13 = load v0
    v14 = load v1
    v15 = load v2
    v16 = load v3
    v18 = eq v15, u32 3
    jmpif v18 then: b2, else: b1
  b2():
    call f22(v0, v1, v2, v3)
    v40 = load v0
    v41 = load v1
    v42 = load v2
    v43 = load v3
    v45 = array_set v40, index u32 0, value v4
    store v45 at v0
    store v41 at v1
    store v42 at v2
    store v43 at v3
    v46 = load v0
    v47 = load v1
    v48 = load v2
    v49 = load v3
    store v46 at v0
    store v47 at v1
    store u32 1 at v2
    store v49 at v3
    jmp b3()
  b3():
    v50 = load v0
    dec_rc v50
    v51 = load v1
    dec_rc v51
    return 
  b1():
    v19 = load v0
    v20 = load v1
    v21 = load v2
    v22 = load v3
    v23 = load v0
    v24 = load v1
    v25 = load v2
    v26 = load v3
    v27 = array_set v19, index v25, value v4
    v29 = add v25, u32 1
    store v27 at v0
    store v20 at v1
    store v21 at v2
    store v22 at v3
    v30 = load v0
    v31 = load v1
    v32 = load v2
    v33 = load v3
    v34 = load v0
    v35 = load v1
    v36 = load v2
    v37 = load v3
    v38 = add v36, u32 1
    store v30 at v0
    store v31 at v1
    store v38 at v2
    store v33 at v3
    jmp b3()
}
brillig fn squeeze f21 {
  b0(v0: &mut [Field; 3], v1: &mut [Field; 4], v2: &mut u32, v3: &mut u1):
    v4 = load v0
    inc_rc v4
    v5 = load v1
    inc_rc v5
    v6 = load v0
    v7 = load v1
    v8 = load v2
    v9 = load v3
    v10 = not v9
    constrain v9 == u1 0
    call f22(v0, v1, v2, v3)
    v13 = load v0
    v14 = load v1
    v15 = load v2
    v16 = load v3
    store v13 at v0
    store v14 at v1
    store v15 at v2
    store u1 1 at v3
    v18 = load v0
    v19 = load v1
    v20 = load v2
    v21 = load v3
    v23 = array_get v19, index u32 0
    v24 = load v0
    dec_rc v24
    v25 = load v1
    dec_rc v25
    return v23
}
brillig fn perform_duplex f22 {
  b0(v0: &mut [Field; 3], v1: &mut [Field; 4], v2: &mut u32, v3: &mut u1):
    v5 = load v0
    inc_rc v5
    v6 = load v1
    inc_rc v6
    jmp b1(u32 0)
  b1(v4: u32):
    v9 = lt v4, u32 3
    jmpif v9 then: b3, else: b2
  b3():
    v23 = load v0
    v24 = load v1
    v25 = load v2
    v26 = load v3
    v27 = lt v4, v25
    jmpif v27 then: b4, else: b5
  b4():
    v28 = load v0
    v29 = load v1
    v30 = load v2
    v31 = load v3
    v32 = load v0
    v33 = load v1
    v34 = load v2
    v35 = load v3
    v36 = array_get v33, index v4
    v37 = load v0
    v38 = load v1
    v39 = load v2
    v40 = load v3
    v41 = array_get v37, index v4
    v42 = add v36, v41
    v43 = array_set v29, index v4, value v42
    v45 = add v4, u32 1
    store v28 at v0
    store v43 at v1
    store v30 at v2
    store v31 at v3
    jmp b5()
  b5():
    v46 = add v4, u32 1
    jmp b1(v46)
  b2():
    v10 = load v0
    v11 = load v1
    v12 = load v2
    v13 = load v3
    v14 = load v0
    v15 = load v1
    v16 = load v2
    v17 = load v3
    v20 = call poseidon2_permutation(v15, u32 4)
    inc_rc v20
    store v10 at v0
    store v20 at v1
    store v12 at v2
    store v13 at v3
    v21 = load v0
    dec_rc v21
    v22 = load v1
    dec_rc v22
    return 
}
brillig fn write f23 {
  b0(v0: &mut u32, v1: &mut [Field], v2: Field):
    v3 = load v1
    inc_rc v3
    v4 = load v0
    v5 = load v1
    v6 = load v0
    v7 = load v1
    v9, v10 = call slice_push_back(v6, v7, v2)
    inc_rc v10
    store v9 at v0
    store v10 at v1
    v11 = load v1
    dec_rc v11
    return 
}
brillig fn default f24 {
  b0():
    inc_rc []
    return u32 0, []
}
brillig fn capacity f25 {
  b0(v0: u32, v1: [u1, Field, Field, u1], v2: u32):
    return v0
}
brillig fn with_hasher_and_capacity f26 {
  b0(v0: u32):
    v2 = allocate
    store u32 0 at v2
    inc_rc []
    v5 = allocate
    store [] at v5
    jmp b1(u32 0)
  b1(v1: u32):
    v6 = lt v1, v0
    jmpif v6 then: b3, else: b2
  b3():
    v9 = load v2
    v10 = load v5
    v12, v13, v14, v15 = call f31()
    v17, v18 = call slice_push_back(v9, v10, v12, v13, v14, v15)
    inc_rc v18
    store v17 at v2
    store v18 at v5
    v20 = add v1, u32 1
    jmp b1(v20)
  b2():
    v7 = load v2
    v8 = load v5
    inc_rc v8
    return v7, v8, u32 0
}
brillig fn entries f27 {
  b0(v0: u32, v1: [u1, Field, Field, u1], v2: u32):
    v4 = allocate
    store u32 0 at v4
    inc_rc []
    v7 = allocate
    store [] at v7
    inc_rc v1
    jmp b1(u32 0)
  b1(v3: u32):
    v8 = lt v3, v0
    jmpif v8 then: b3, else: b2
  b3():
    v42 = mul v3, u32 4
    v43 = lt v3, v0
    constrain v43 == u1 1 '"Index out of bounds"'
    v45 = array_get v1, index v42
    v47 = add v42, u32 1
    v48 = lt v3, v0
    constrain v48 == u1 1 '"Index out of bounds"'
    v49 = array_get v1, index v47
    v51 = add v42, u32 2
    v52 = lt v3, v0
    constrain v52 == u1 1 '"Index out of bounds"'
    v53 = array_get v1, index v51
    v55 = add v42, u32 3
    v56 = lt v3, v0
    constrain v56 == u1 1 '"Index out of bounds"'
    v57 = array_get v1, index v55
    v59 = call f28(v45, v49, v53, v57)
    jmpif v59 then: b4, else: b5
  b4():
    v61, v62, v63 = call f29(v45, v49, v53, v57)
    v65, v66 = call f14(v61, v62, v63)
    v67 = load v4
    v68 = load v7
    v70, v71 = call slice_push_back(v67, v68, v65, v66)
    inc_rc v71
    store v70 at v4
    store v71 at v7
    jmp b5()
  b5():
    v72 = add v3, u32 1
    jmp b1(v72)
  b2():
    inc_rc [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46]
    v36 = load v4
    v37 = load v7
    v38 = eq v36, v2
    constrain v36 == v2, data [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46], u32 0
    v39 = load v4
    v40 = load v7
    return v39, v40
}
brillig fn is_valid f28 {
  b0(v0: u1, v1: Field, v2: Field, v3: u1):
    v4 = not v3
    v6 = call f30(v0, v1, v2)
    v7 = mul v4, v6
    return v7
}
brillig fn key_value f29 {
  b0(v0: u1, v1: Field, v2: Field, v3: u1):
    return v0, v1, v2
}
brillig fn is_some f30 {
  b0(v0: u1, v1: Field, v2: Field):
    return v0
}
brillig fn default f31 {
  b0():
    v1, v2, v3 = call f32()
    return v1, v2, v3, u1 0
}
brillig fn none f32 {
  b0():
    return u1 0, Field 0, Field 0
}
brillig fn default f33 {
  b0():
    call f35()
    v2, v3, v4 = call f34()
    return v2, v3, v4
}
brillig fn with_hasher f34 {
  b0():
    v1, v2, v3, v4 = call f31()
    inc_rc [v1, v2, v3, v4]
    inc_rc [v1, v2, v3, v4]
    return u32 1, [v1, v2, v3, v4], u32 0
}
brillig fn default f35 {
  b0():
    return 
}

After Inlining:
brillig fn main f0 {
  b0(v0: [Field, Field; 6]):
    v2 = array_get v0, index u32 0
    v4 = array_get v0, index u32 1
    v5 = array_get v0, index u32 0
    v6 = array_get v0, index u32 1
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    v10 = allocate
    store u32 1 at v10
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    v11 = allocate
    store [u1 0, Field 0, Field 0, u1 0] at v11
    v12 = allocate
    store u32 0 at v12
    v13 = load v10
    v14 = load v11
    v15 = load v12
    v16 = eq v15, u32 0
    constrain v15 == u32 0 '"New UHashMap should be empty."'
    call f1(v10, v11, v12, v2, v6)
    v18 = load v10
    v19 = load v11
    v20 = load v12
    v21 = eq v20, u32 1
    constrain v20 == u32 1 '"UHashMap after one insert should have a length of 1 element."'
    return 
}
brillig fn insert f1 {
  b0(v0: &mut u32, v1: &mut [u1, Field, Field, u1], v2: &mut u32, v3: Field, v4: Field):
    v12 = load v1
    inc_rc v12
    v13 = load v1
    inc_rc v13
    v14 = load v0
    v15 = load v1
    v16 = load v2
    v18 = add v16, u32 1
    v19 = load v0
    v20 = load v1
    v21 = load v2
    v23 = div v19, u32 2
    v24 = lt v18, v23
    v25 = not v24
    jmpif v25 then: b1, else: b8
  b1():
    v26 = load v0
    v27 = load v1
    v28 = load v2
    v29 = mul v26, u32 2
    v30 = load v0
    v31 = load v1
    v32 = load v2
    v33 = allocate
    store u32 0 at v33
    inc_rc []
    v36 = allocate
    store [] at v36
    jmp b2(u32 0)
  b2(v5: u32):
    v37 = lt v5, v29
    jmpif v37 then: b39, else: b3
  b39():
    v378 = load v33
    v379 = load v36
    v380, v381 = call slice_push_back(v378, v379, u1 0, Field 0, Field 0, u1 0)
    inc_rc v381
    store v380 at v33
    store v381 at v36
    v382 = add v5, u32 1
    jmp b2(v382)
  b3():
    v38 = load v33
    v39 = load v36
    inc_rc v39
    v40 = allocate
    store v38 at v40
    inc_rc v39
    v41 = allocate
    store v39 at v41
    v42 = allocate
    store u32 0 at v42
    v43 = load v0
    v44 = load v1
    v45 = load v2
    v46 = allocate
    store u32 0 at v46
    inc_rc []
    v48 = allocate
    store [] at v48
    inc_rc v44
    jmp b4(u32 0)
  b4(v6: u32):
    v49 = lt v6, v43
    jmpif v49 then: b36, else: b5
  b36():
    v359 = mul v6, u32 4
    v360 = lt v6, v43
    constrain v360 == u1 1 '"Index out of bounds"'
    v361 = array_get v44, index v359
    v362 = add v359, u32 1
    v363 = lt v6, v43
    constrain v363 == u1 1 '"Index out of bounds"'
    v364 = array_get v44, index v362
    v365 = add v359, u32 2
    v366 = lt v6, v43
    constrain v366 == u1 1 '"Index out of bounds"'
    v367 = array_get v44, index v365
    v368 = add v359, u32 3
    v369 = lt v6, v43
    constrain v369 == u1 1 '"Index out of bounds"'
    v370 = array_get v44, index v368
    v371 = not v370
    v372 = mul v371, v361
    jmpif v372 then: b37, else: b38
  b37():
    v373 = load v46
    v374 = load v48
    v375, v376 = call slice_push_back(v373, v374, v364, v367)
    inc_rc v376
    store v375 at v46
    store v376 at v48
    jmp b38()
  b38():
    v377 = add v6, u32 1
    jmp b4(v377)
  b5():
    inc_rc [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46]
    v77 = load v46
    v78 = load v48
    v79 = eq v77, v45
    constrain v77 == v45, data [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46], u32 0
    v80 = load v46
    v81 = load v48
    inc_rc v81
    jmp b6(u32 0)
  b6(v7: u32):
    v82 = lt v7, v80
    jmpif v82 then: b35, else: b7
  b35():
    v351 = mul v7, u32 2
    v352 = lt v7, v80
    constrain v352 == u1 1 '"Index out of bounds"'
    v353 = array_get v81, index v351
    v354 = add v351, u32 1
    v355 = lt v7, v80
    constrain v355 == u1 1 '"Index out of bounds"'
    v356 = array_get v81, index v354
    call f1(v40, v41, v42, v353, v356)
    v358 = add v7, u32 1
    jmp b6(v358)
  b7():
    v83 = load v40
    v84 = load v41
    v85 = load v42
    inc_rc v84
    store v83 at v0
    store v84 at v1
    store v85 at v2
    jmp b8()
  b8():
    v86 = load v1
    dec_rc v86
    v87 = load v0
    v88 = load v1
    v89 = load v2
    inc_rc []
    v91 = allocate
    store u32 0 at v91
    inc_rc []
    v92 = allocate
    store [] at v92
    v93 = load v92
    inc_rc v93
    v94 = load v92
    inc_rc v94
    v95 = load v91
    v96 = load v92
    v97 = load v91
    v98 = load v92
    v100, v101 = call slice_push_back(v97, v98, v3)
    inc_rc v101
    store v100 at v91
    store v101 at v92
    v102 = load v92
    dec_rc v102
    v103 = load v92
    dec_rc v103
    v104 = load v91
    v105 = load v92
    v106 = cast v104 as Field
    v108 = mul v106, Field 2⁶⁴
    inc_rc [Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0]
    v112 = allocate
    store [Field 0, Field 0, Field 0] at v112
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    v113 = allocate
    store [Field 0, Field 0, Field 0, Field 0] at v113
    v114 = allocate
    store u32 0 at v114
    v115 = allocate
    store u1 0 at v115
    v117 = load v112
    v118 = load v113
    v119 = load v114
    v120 = load v115
    v122 = array_set v118, index u32 3, value v108
    store v117 at v112
    store v122 at v113
    store v119 at v114
    store v120 at v115
    v123 = load v112
    v124 = load v113
    v125 = load v114
    v126 = load v115
    inc_rc v123
    v127 = allocate
    store v123 at v127
    inc_rc v124
    v128 = allocate
    store v124 at v128
    v129 = allocate
    store v125 at v129
    v130 = allocate
    store v126 at v130
    jmp b9(u32 0)
  b9(v8: u32):
    v131 = lt v8, v104
    jmpif v131 then: b26, else: b10
  b26():
    v269 = lt v8, v104
    constrain v269 == u1 1 '"Index out of bounds"'
    v270 = array_get v105, index v8
    v271 = load v127
    inc_rc v271
    v272 = load v128
    inc_rc v272
    v273 = load v127
    v274 = load v128
    v275 = load v129
    v276 = load v130
    v277 = not v276
    constrain v276 == u1 0
    v278 = load v127
    v279 = load v128
    v280 = load v129
    v281 = load v130
    v282 = eq v280, u32 3
    jmpif v282 then: b28, else: b27
  b28():
    v302 = load v127
    inc_rc v302
    v303 = load v128
    inc_rc v303
    jmp b29(u32 0)
  b29(v11: u32):
    v304 = lt v11, u32 3
    jmpif v304 then: b32, else: b30
  b32():
    v328 = load v127
    v329 = load v128
    v330 = load v129
    v331 = load v130
    v332 = lt v11, v330
    jmpif v332 then: b33, else: b34
  b33():
    v333 = load v127
    v334 = load v128
    v335 = load v129
    v336 = load v130
    v337 = load v127
    v338 = load v128
    v339 = load v129
    v340 = load v130
    v341 = array_get v338, index v11
    v342 = load v127
    v343 = load v128
    v344 = load v129
    v345 = load v130
    v346 = array_get v342, index v11
    v347 = add v341, v346
    v348 = array_set v334, index v11, value v347
    v349 = add v11, u32 1
    store v333 at v127
    store v348 at v128
    store v335 at v129
    store v336 at v130
    jmp b34()
  b34():
    v350 = add v11, u32 1
    jmp b29(v350)
  b30():
    v305 = load v127
    v306 = load v128
    v307 = load v129
    v308 = load v130
    v309 = load v127
    v310 = load v128
    v311 = load v129
    v312 = load v130
    v313 = call poseidon2_permutation(v310, u32 4)
    inc_rc v313
    store v305 at v127
    store v313 at v128
    store v307 at v129
    store v308 at v130
    v314 = load v127
    dec_rc v314
    v315 = load v128
    dec_rc v315
    v316 = load v127
    v317 = load v128
    v318 = load v129
    v319 = load v130
    v320 = array_set v316, index u32 0, value v270
    store v320 at v127
    store v317 at v128
    store v318 at v129
    store v319 at v130
    v321 = load v127
    v322 = load v128
    v323 = load v129
    v324 = load v130
    store v321 at v127
    store v322 at v128
    store u32 1 at v129
    store v324 at v130
    jmp b31()
  b31():
    v325 = load v127
    dec_rc v325
    v326 = load v128
    dec_rc v326
    v327 = add v8, u32 1
    jmp b9(v327)
  b27():
    v283 = load v127
    v284 = load v128
    v285 = load v129
    v286 = load v130
    v287 = load v127
    v288 = load v128
    v289 = load v129
    v290 = load v130
    v291 = array_set v283, index v289, value v270
    v292 = add v289, u32 1
    store v291 at v127
    store v284 at v128
    store v285 at v129
    store v286 at v130
    v293 = load v127
    v294 = load v128
    v295 = load v129
    v296 = load v130
    v297 = load v127
    v298 = load v128
    v299 = load v129
    v300 = load v130
    v301 = add v299, u32 1
    store v293 at v127
    store v294 at v128
    store v301 at v129
    store v296 at v130
    jmp b31()
  b10():
    v132 = load v127
    inc_rc v132
    v133 = load v128
    inc_rc v133
    v134 = load v127
    v135 = load v128
    v136 = load v129
    v137 = load v130
    v138 = not v137
    constrain v137 == u1 0
    v139 = load v127
    inc_rc v139
    v140 = load v128
    inc_rc v140
    jmp b11(u32 0)
  b11(v9: u32):
    v141 = lt v9, u32 3
    jmpif v141 then: b23, else: b12
  b23():
    v246 = load v127
    v247 = load v128
    v248 = load v129
    v249 = load v130
    v250 = lt v9, v248
    jmpif v250 then: b24, else: b25
  b24():
    v251 = load v127
    v252 = load v128
    v253 = load v129
    v254 = load v130
    v255 = load v127
    v256 = load v128
    v257 = load v129
    v258 = load v130
    v259 = array_get v256, index v9
    v260 = load v127
    v261 = load v128
    v262 = load v129
    v263 = load v130
    v264 = array_get v260, index v9
    v265 = add v259, v264
    v266 = array_set v252, index v9, value v265
    v267 = add v9, u32 1
    store v251 at v127
    store v266 at v128
    store v253 at v129
    store v254 at v130
    jmp b25()
  b25():
    v268 = add v9, u32 1
    jmp b11(v268)
  b12():
    v142 = load v127
    v143 = load v128
    v144 = load v129
    v145 = load v130
    v146 = load v127
    v147 = load v128
    v148 = load v129
    v149 = load v130
    v152 = call poseidon2_permutation(v147, u32 4)
    inc_rc v152
    store v142 at v127
    store v152 at v128
    store v144 at v129
    store v145 at v130
    v153 = load v127
    dec_rc v153
    v154 = load v128
    dec_rc v154
    v155 = load v127
    v156 = load v128
    v157 = load v129
    v158 = load v130
    store v155 at v127
    store v156 at v128
    store v157 at v129
    store u1 1 at v130
    v160 = load v127
    v161 = load v128
    v162 = load v129
    v163 = load v130
    v164 = array_get v161, index u32 0
    v165 = load v127
    dec_rc v165
    v166 = load v128
    dec_rc v166
    v167 = truncate v164 to 32 bits, max_bit_size: 254
    v168 = cast v167 as u32
    v169 = load v0
    v170 = load v1
    v171 = load v2
    jmp b13(u32 0)
  b13(v10: u32):
    v172 = lt v10, v169
    jmpif v172 then: b14, else: b22
  b14():
    v173 = load v0
    v174 = load v1
    v175 = load v2
    v176 = mul v10, v10
    v177 = add v10, v176
    v178 = div v177, u32 2
    v179 = add v168, v178
    v180 = mod v179, v173
    v181 = load v0
    v182 = load v1
    v183 = load v2
    v184 = mul v180, u32 4
    v185 = lt v180, v181
    constrain v185 == u1 1 '"Index out of bounds"'
    v186 = array_get v182, index v184
    v187 = add v184, u32 1
    v188 = lt v180, v181
    constrain v188 == u1 1 '"Index out of bounds"'
    v189 = array_get v182, index v187
    v190 = add v184, u32 2
    v191 = lt v180, v181
    constrain v191 == u1 1 '"Index out of bounds"'
    v192 = array_get v182, index v190
    v193 = add v184, u32 3
    v194 = lt v180, v181
    constrain v194 == u1 1 '"Index out of bounds"'
    v195 = array_get v182, index v193
    v196 = allocate
    store v186 at v196
    v197 = allocate
    store v189 at v197
    v198 = allocate
    store v192 at v198
    v199 = allocate
    store v195 at v199
    v200 = allocate
    store u1 0 at v200
    v201 = load v196
    v202 = load v197
    v203 = load v198
    v204 = load v199
    v205 = not v201
    v206 = or v204, v205
    jmpif v206 then: b18, else: b15
  b18():
    store u1 1 at v200
    v212 = load v0
    v213 = load v1
    v214 = load v2
    v215 = load v0
    v216 = load v1
    v217 = load v2
    v218 = add v217, u32 1
    store v212 at v0
    store v213 at v1
    store v218 at v2
    jmp b19()
  b19():
    v219 = load v200
    jmpif v219 then: b21, else: b20
  b21():
    v221 = load v196
    v222 = load v197
    v223 = load v198
    v224 = load v199
    store u1 1 at v196
    store v3 at v197
    store v4 at v198
    store v224 at v199
    v225 = load v196
    v226 = load v197
    v227 = load v198
    v228 = load v199
    store v225 at v196
    store v226 at v197
    store v227 at v198
    store u1 0 at v199
    v229 = load v0
    v230 = load v1
    v231 = load v2
    v232 = load v196
    v233 = load v197
    v234 = load v198
    v235 = load v199
    v236 = mul v180, u32 4
    v237 = array_set v230, index v236, value v232
    v238 = add v236, u32 1
    v239 = array_set v237, index v238, value v233
    v240 = add v238, u32 1
    v241 = array_set v239, index v240, value v234
    v242 = add v240, u32 1
    v243 = array_set v241, index v242, value v235
    v244 = add v242, u32 1
    store v229 at v0
    store v243 at v1
    store v231 at v2
    jmp b22()
  b22():
    v245 = load v1
    dec_rc v245
    return 
  b20():
    v220 = add v10, u32 1
    jmp b13(v220)
  b15():
    v207 = load v196
    v208 = load v197
    v209 = load v198
    v210 = load v199
    v211 = eq v208, v3
    jmpif v211 then: b16, else: b17
  b16():
    store u1 1 at v200
    jmp b17()
  b17():
    jmp b19()
}

After Mem2Reg:
brillig fn main f0 {
  b0(v0: [Field, Field; 6]):
    v2 = array_get v0, index u32 0
    v4 = array_get v0, index u32 1
    v5 = array_get v0, index u32 0
    v6 = array_get v0, index u32 1
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    v10 = allocate
    store u32 1 at v10
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    v11 = allocate
    store [u1 0, Field 0, Field 0, u1 0] at v11
    v12 = allocate
    store u32 0 at v12
    call f1(v10, v11, v12, v2, v6)
    constrain u32 0 == u32 1 '"UHashMap after one insert should have a length of 1 element."'
    return 
}
brillig fn insert f1 {
  b0(v0: &mut u32, v1: &mut [u1, Field, Field, u1], v2: &mut u32, v3: Field, v4: Field):
    v12 = load v1
    inc_rc v12
    inc_rc v12
    v13 = load v0
    v14 = load v2
    v16 = add v14, u32 1
    v18 = div v13, u32 2
    v19 = lt v16, v18
    v20 = not v19
    jmpif v20 then: b1, else: b8
  b1():
    v21 = load v0
    v22 = mul v21, u32 2
    v23 = allocate
    store u32 0 at v23
    inc_rc []
    v26 = allocate
    store [] at v26
    jmp b2(u32 0)
  b2(v5: u32):
    v27 = lt v5, v22
    jmpif v27 then: b39, else: b3
  b39():
    v226 = load v23
    v227 = load v26
    v228, v229 = call slice_push_back(v226, v227, u1 0, Field 0, Field 0, u1 0)
    inc_rc v229
    store v228 at v23
    store v229 at v26
    v230 = add v5, u32 1
    jmp b2(v230)
  b3():
    v28 = load v23
    v29 = load v26
    inc_rc v29
    v30 = allocate
    store v28 at v30
    inc_rc v29
    v31 = allocate
    store v29 at v31
    v32 = allocate
    store u32 0 at v32
    v33 = load v0
    v34 = load v1
    v35 = load v2
    v36 = allocate
    store u32 0 at v36
    inc_rc []
    v38 = allocate
    store [] at v38
    inc_rc v34
    jmp b4(u32 0)
  b4(v6: u32):
    v39 = lt v6, v33
    jmpif v39 then: b36, else: b5
  b36():
    v206 = mul v6, u32 4
    v207 = lt v6, v33
    constrain v207 == u1 1 '"Index out of bounds"'
    v208 = array_get v34, index v206
    v209 = add v206, u32 1
    v210 = lt v6, v33
    constrain v210 == u1 1 '"Index out of bounds"'
    v211 = array_get v34, index v209
    v212 = add v206, u32 2
    v213 = lt v6, v33
    constrain v213 == u1 1 '"Index out of bounds"'
    v214 = array_get v34, index v212
    v215 = add v206, u32 3
    v216 = lt v6, v33
    constrain v216 == u1 1 '"Index out of bounds"'
    v217 = array_get v34, index v215
    v218 = not v217
    v219 = mul v218, v208
    jmpif v219 then: b37, else: b38
  b37():
    v220 = load v36
    v221 = load v38
    v223, v224 = call slice_push_back(v220, v221, v211, v214)
    inc_rc v224
    store v223 at v36
    store v224 at v38
    jmp b38()
  b38():
    v225 = add v6, u32 1
    jmp b4(v225)
  b5():
    inc_rc [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46]
    v67 = load v36
    v68 = load v38
    v69 = eq v67, v35
    constrain v67 == v35, data [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46], u32 0
    inc_rc v68
    jmp b6(u32 0)
  b6(v7: u32):
    v70 = lt v7, v67
    jmpif v70 then: b35, else: b7
  b35():
    v198 = mul v7, u32 2
    v199 = lt v7, v67
    constrain v199 == u1 1 '"Index out of bounds"'
    v200 = array_get v68, index v198
    v201 = add v198, u32 1
    v202 = lt v7, v67
    constrain v202 == u1 1 '"Index out of bounds"'
    v203 = array_get v68, index v201
    call f1(v30, v31, v32, v200, v203)
    v205 = add v7, u32 1
    jmp b6(v205)
  b7():
    v71 = load v30
    v72 = load v31
    v73 = load v32
    inc_rc v72
    store v71 at v0
    store v72 at v1
    store v73 at v2
    jmp b8()
  b8():
    v74 = load v1
    dec_rc v74
    inc_rc []
    v76 = allocate
    inc_rc []
    v77 = allocate
    inc_rc []
    inc_rc []
    inc_rc [v3]
    dec_rc [v3]
    dec_rc [v3]
    inc_rc [Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0]
    v82 = allocate
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    v83 = allocate
    v84 = allocate
    v85 = allocate
    inc_rc [Field 0, Field 0, Field 0]
    v86 = allocate
    store [Field 0, Field 0, Field 0] at v86
    inc_rc [Field 0, Field 0, Field 0, Field 2⁶⁴]
    v89 = allocate
    store [Field 0, Field 0, Field 0, Field 2⁶⁴] at v89
    v90 = allocate
    store u32 0 at v90
    v91 = allocate
    store u1 0 at v91
    jmp b9(u32 0)
  b9(v8: u32):
    v93 = eq v8, u32 0
    jmpif v93 then: b26, else: b10
  b26():
    v165 = eq v8, u32 0
    constrain v8 == u32 0 '"Index out of bounds"'
    v166 = array_get [v3], index v8
    v167 = load v86
    inc_rc v167
    v168 = load v89
    inc_rc v168
    v169 = load v90
    v170 = load v91
    v171 = not v170
    constrain v170 == u1 0
    v172 = eq v169, u32 3
    jmpif v172 then: b28, else: b27
  b28():
    v178 = load v86
    inc_rc v178
    v179 = load v89
    inc_rc v179
    jmp b29(u32 0)
  b29(v11: u32):
    v180 = lt v11, u32 3
    jmpif v180 then: b32, else: b30
  b32():
    v188 = load v90
    v189 = lt v11, v188
    jmpif v189 then: b33, else: b34
  b33():
    v190 = load v86
    v191 = load v89
    v192 = array_get v191, index v11
    v193 = array_get v190, index v11
    v194 = add v192, v193
    v195 = array_set v191, index v11, value v194
    v196 = add v11, u32 1
    store v195 at v89
    jmp b34()
  b34():
    v197 = add v11, u32 1
    jmp b29(v197)
  b30():
    v181 = load v86
    v182 = load v89
    v183 = call poseidon2_permutation(v182, u32 4)
    inc_rc v183
    dec_rc v181
    dec_rc v183
    v184 = array_set v181, index u32 0, value v166
    store v184 at v86
    store v183 at v89
    store u32 1 at v90
    jmp b31()
  b31():
    v185 = load v86
    dec_rc v185
    v186 = load v89
    dec_rc v186
    v187 = add v8, u32 1
    jmp b9(v187)
  b27():
    v173 = load v86
    v174 = load v90
    v175 = array_set v173, index v174, value v166
    v176 = add v174, u32 1
    v177 = add v174, u32 1
    store v175 at v86
    store v177 at v90
    jmp b31()
  b10():
    v94 = load v86
    inc_rc v94
    v95 = load v89
    inc_rc v95
    v96 = load v91
    v97 = not v96
    constrain v96 == u1 0
    inc_rc v94
    inc_rc v95
    jmp b11(u32 0)
  b11(v9: u32):
    v99 = lt v9, u32 3
    jmpif v99 then: b23, else: b12
  b23():
    v155 = load v90
    v156 = lt v9, v155
    jmpif v156 then: b24, else: b25
  b24():
    v157 = load v86
    v158 = load v89
    v159 = array_get v158, index v9
    v160 = array_get v157, index v9
    v161 = add v159, v160
    v162 = array_set v158, index v9, value v161
    v163 = add v9, u32 1
    store v162 at v89
    jmp b25()
  b25():
    v164 = add v9, u32 1
    jmp b11(v164)
  b12():
    v100 = load v86
    v101 = load v89
    v104 = call poseidon2_permutation(v101, u32 4)
    inc_rc v104
    dec_rc v100
    dec_rc v104
    store v104 at v89
    store u1 1 at v91
    v106 = array_get v104, index u32 0
    dec_rc v100
    dec_rc v104
    v107 = truncate v106 to 32 bits, max_bit_size: 254
    v108 = cast v107 as u32
    v109 = load v0
    jmp b13(u32 0)
  b13(v10: u32):
    v110 = lt v10, v109
    jmpif v110 then: b14, else: b22
  b14():
    v111 = load v0
    v112 = load v1
    v113 = mul v10, v10
    v114 = add v10, v113
    v115 = div v114, u32 2
    v116 = add v108, v115
    v117 = mod v116, v111
    v118 = mul v117, u32 4
    v119 = lt v117, v111
    constrain v119 == u1 1 '"Index out of bounds"'
    v120 = array_get v112, index v118
    v121 = add v118, u32 1
    v122 = lt v117, v111
    constrain v122 == u1 1 '"Index out of bounds"'
    v123 = array_get v112, index v121
    v124 = add v118, u32 2
    v125 = lt v117, v111
    constrain v125 == u1 1 '"Index out of bounds"'
    v126 = array_get v112, index v124
    v127 = add v118, u32 3
    v128 = lt v117, v111
    constrain v128 == u1 1 '"Index out of bounds"'
    v129 = array_get v112, index v127
    v130 = allocate
    v131 = allocate
    v132 = allocate
    v133 = allocate
    v134 = allocate
    store u1 0 at v134
    v135 = not v120
    v136 = or v129, v135
    jmpif v136 then: b18, else: b15
  b18():
    store u1 1 at v134
    v138 = load v1
    v139 = load v2
    v140 = add v139, u32 1
    store v138 at v1
    store v140 at v2
    jmp b19()
  b19():
    v141 = load v134
    jmpif v141 then: b21, else: b20
  b21():
    store u1 1 at v130
    store v3 at v131
    store v4 at v132
    store u1 0 at v133
    v143 = load v1
    v144 = load v2
    v145 = mul v117, u32 4
    v146 = array_set v143, index v145, value u1 1
    v147 = add v145, u32 1
    v148 = array_set v146, index v147, value v3
    v149 = add v147, u32 1
    v150 = array_set v148, index v149, value v4
    v151 = add v149, u32 1
    v152 = array_set v150, index v151, value u1 0
    v153 = add v151, u32 1
    store v152 at v1
    store v144 at v2
    jmp b22()
  b22():
    v154 = load v1
    dec_rc v154
    return 
  b20():
    v142 = add v10, u32 1
    jmp b13(v142)
  b15():
    v137 = eq v123, v3
    jmpif v137 then: b16, else: b17
  b16():
    store u1 1 at v134
    jmp b17()
  b17():
    jmp b19()
}

After `as_slice` optimization
brillig fn main f0 {
  b0(v0: [Field, Field; 6]):
    v2 = array_get v0, index u32 0
    v4 = array_get v0, index u32 1
    v5 = array_get v0, index u32 0
    v6 = array_get v0, index u32 1
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    v10 = allocate
    store u32 1 at v10
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    v11 = allocate
    store [u1 0, Field 0, Field 0, u1 0] at v11
    v12 = allocate
    store u32 0 at v12
    call f1(v10, v11, v12, v2, v6)
    constrain u32 0 == u32 1 '"UHashMap after one insert should have a length of 1 element."'
    return 
}
brillig fn insert f1 {
  b0(v0: &mut u32, v1: &mut [u1, Field, Field, u1], v2: &mut u32, v3: Field, v4: Field):
    v12 = load v1
    inc_rc v12
    inc_rc v12
    v13 = load v0
    v14 = load v2
    v16 = add v14, u32 1
    v18 = div v13, u32 2
    v19 = lt v16, v18
    v20 = not v19
    jmpif v20 then: b1, else: b8
  b1():
    v21 = load v0
    v22 = mul v21, u32 2
    v23 = allocate
    store u32 0 at v23
    inc_rc []
    v26 = allocate
    store [] at v26
    jmp b2(u32 0)
  b2(v5: u32):
    v27 = lt v5, v22
    jmpif v27 then: b39, else: b3
  b39():
    v226 = load v23
    v227 = load v26
    v228, v229 = call slice_push_back(v226, v227, u1 0, Field 0, Field 0, u1 0)
    inc_rc v229
    store v228 at v23
    store v229 at v26
    v230 = add v5, u32 1
    jmp b2(v230)
  b3():
    v28 = load v23
    v29 = load v26
    inc_rc v29
    v30 = allocate
    store v28 at v30
    inc_rc v29
    v31 = allocate
    store v29 at v31
    v32 = allocate
    store u32 0 at v32
    v33 = load v0
    v34 = load v1
    v35 = load v2
    v36 = allocate
    store u32 0 at v36
    inc_rc []
    v38 = allocate
    store [] at v38
    inc_rc v34
    jmp b4(u32 0)
  b4(v6: u32):
    v39 = lt v6, v33
    jmpif v39 then: b36, else: b5
  b36():
    v206 = mul v6, u32 4
    v207 = lt v6, v33
    constrain v207 == u1 1 '"Index out of bounds"'
    v208 = array_get v34, index v206
    v209 = add v206, u32 1
    v210 = lt v6, v33
    constrain v210 == u1 1 '"Index out of bounds"'
    v211 = array_get v34, index v209
    v212 = add v206, u32 2
    v213 = lt v6, v33
    constrain v213 == u1 1 '"Index out of bounds"'
    v214 = array_get v34, index v212
    v215 = add v206, u32 3
    v216 = lt v6, v33
    constrain v216 == u1 1 '"Index out of bounds"'
    v217 = array_get v34, index v215
    v218 = not v217
    v219 = mul v218, v208
    jmpif v219 then: b37, else: b38
  b37():
    v220 = load v36
    v221 = load v38
    v223, v224 = call slice_push_back(v220, v221, v211, v214)
    inc_rc v224
    store v223 at v36
    store v224 at v38
    jmp b38()
  b38():
    v225 = add v6, u32 1
    jmp b4(v225)
  b5():
    inc_rc [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46]
    v67 = load v36
    v68 = load v38
    v69 = eq v67, v35
    constrain v67 == v35, data [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46], u32 0
    inc_rc v68
    jmp b6(u32 0)
  b6(v7: u32):
    v70 = lt v7, v67
    jmpif v70 then: b35, else: b7
  b35():
    v198 = mul v7, u32 2
    v199 = lt v7, v67
    constrain v199 == u1 1 '"Index out of bounds"'
    v200 = array_get v68, index v198
    v201 = add v198, u32 1
    v202 = lt v7, v67
    constrain v202 == u1 1 '"Index out of bounds"'
    v203 = array_get v68, index v201
    call f1(v30, v31, v32, v200, v203)
    v205 = add v7, u32 1
    jmp b6(v205)
  b7():
    v71 = load v30
    v72 = load v31
    v73 = load v32
    inc_rc v72
    store v71 at v0
    store v72 at v1
    store v73 at v2
    jmp b8()
  b8():
    v74 = load v1
    dec_rc v74
    inc_rc []
    v76 = allocate
    inc_rc []
    v77 = allocate
    inc_rc []
    inc_rc []
    inc_rc [v3]
    dec_rc [v3]
    dec_rc [v3]
    inc_rc [Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0]
    v82 = allocate
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    v83 = allocate
    v84 = allocate
    v85 = allocate
    inc_rc [Field 0, Field 0, Field 0]
    v86 = allocate
    store [Field 0, Field 0, Field 0] at v86
    inc_rc [Field 0, Field 0, Field 0, Field 2⁶⁴]
    v89 = allocate
    store [Field 0, Field 0, Field 0, Field 2⁶⁴] at v89
    v90 = allocate
    store u32 0 at v90
    v91 = allocate
    store u1 0 at v91
    jmp b9(u32 0)
  b9(v8: u32):
    v93 = eq v8, u32 0
    jmpif v93 then: b26, else: b10
  b26():
    v165 = eq v8, u32 0
    constrain v8 == u32 0 '"Index out of bounds"'
    v166 = array_get [v3], index v8
    v167 = load v86
    inc_rc v167
    v168 = load v89
    inc_rc v168
    v169 = load v90
    v170 = load v91
    v171 = not v170
    constrain v170 == u1 0
    v172 = eq v169, u32 3
    jmpif v172 then: b28, else: b27
  b28():
    v178 = load v86
    inc_rc v178
    v179 = load v89
    inc_rc v179
    jmp b29(u32 0)
  b29(v11: u32):
    v180 = lt v11, u32 3
    jmpif v180 then: b32, else: b30
  b32():
    v188 = load v90
    v189 = lt v11, v188
    jmpif v189 then: b33, else: b34
  b33():
    v190 = load v86
    v191 = load v89
    v192 = array_get v191, index v11
    v193 = array_get v190, index v11
    v194 = add v192, v193
    v195 = array_set v191, index v11, value v194
    v196 = add v11, u32 1
    store v195 at v89
    jmp b34()
  b34():
    v197 = add v11, u32 1
    jmp b29(v197)
  b30():
    v181 = load v86
    v182 = load v89
    v183 = call poseidon2_permutation(v182, u32 4)
    inc_rc v183
    dec_rc v181
    dec_rc v183
    v184 = array_set v181, index u32 0, value v166
    store v184 at v86
    store v183 at v89
    store u32 1 at v90
    jmp b31()
  b31():
    v185 = load v86
    dec_rc v185
    v186 = load v89
    dec_rc v186
    v187 = add v8, u32 1
    jmp b9(v187)
  b27():
    v173 = load v86
    v174 = load v90
    v175 = array_set v173, index v174, value v166
    v176 = add v174, u32 1
    v177 = add v174, u32 1
    store v175 at v86
    store v177 at v90
    jmp b31()
  b10():
    v94 = load v86
    inc_rc v94
    v95 = load v89
    inc_rc v95
    v96 = load v91
    v97 = not v96
    constrain v96 == u1 0
    inc_rc v94
    inc_rc v95
    jmp b11(u32 0)
  b11(v9: u32):
    v99 = lt v9, u32 3
    jmpif v99 then: b23, else: b12
  b23():
    v155 = load v90
    v156 = lt v9, v155
    jmpif v156 then: b24, else: b25
  b24():
    v157 = load v86
    v158 = load v89
    v159 = array_get v158, index v9
    v160 = array_get v157, index v9
    v161 = add v159, v160
    v162 = array_set v158, index v9, value v161
    v163 = add v9, u32 1
    store v162 at v89
    jmp b25()
  b25():
    v164 = add v9, u32 1
    jmp b11(v164)
  b12():
    v100 = load v86
    v101 = load v89
    v104 = call poseidon2_permutation(v101, u32 4)
    inc_rc v104
    dec_rc v100
    dec_rc v104
    store v104 at v89
    store u1 1 at v91
    v106 = array_get v104, index u32 0
    dec_rc v100
    dec_rc v104
    v107 = truncate v106 to 32 bits, max_bit_size: 254
    v108 = cast v107 as u32
    v109 = load v0
    jmp b13(u32 0)
  b13(v10: u32):
    v110 = lt v10, v109
    jmpif v110 then: b14, else: b22
  b14():
    v111 = load v0
    v112 = load v1
    v113 = mul v10, v10
    v114 = add v10, v113
    v115 = div v114, u32 2
    v116 = add v108, v115
    v117 = mod v116, v111
    v118 = mul v117, u32 4
    v119 = lt v117, v111
    constrain v119 == u1 1 '"Index out of bounds"'
    v120 = array_get v112, index v118
    v121 = add v118, u32 1
    v122 = lt v117, v111
    constrain v122 == u1 1 '"Index out of bounds"'
    v123 = array_get v112, index v121
    v124 = add v118, u32 2
    v125 = lt v117, v111
    constrain v125 == u1 1 '"Index out of bounds"'
    v126 = array_get v112, index v124
    v127 = add v118, u32 3
    v128 = lt v117, v111
    constrain v128 == u1 1 '"Index out of bounds"'
    v129 = array_get v112, index v127
    v130 = allocate
    v131 = allocate
    v132 = allocate
    v133 = allocate
    v134 = allocate
    store u1 0 at v134
    v135 = not v120
    v136 = or v129, v135
    jmpif v136 then: b18, else: b15
  b18():
    store u1 1 at v134
    v138 = load v1
    v139 = load v2
    v140 = add v139, u32 1
    store v138 at v1
    store v140 at v2
    jmp b19()
  b19():
    v141 = load v134
    jmpif v141 then: b21, else: b20
  b21():
    store u1 1 at v130
    store v3 at v131
    store v4 at v132
    store u1 0 at v133
    v143 = load v1
    v144 = load v2
    v145 = mul v117, u32 4
    v146 = array_set v143, index v145, value u1 1
    v147 = add v145, u32 1
    v148 = array_set v146, index v147, value v3
    v149 = add v147, u32 1
    v150 = array_set v148, index v149, value v4
    v151 = add v149, u32 1
    v152 = array_set v150, index v151, value u1 0
    v153 = add v151, u32 1
    store v152 at v1
    store v144 at v2
    jmp b22()
  b22():
    v154 = load v1
    dec_rc v154
    return 
  b20():
    v142 = add v10, u32 1
    jmp b13(v142)
  b15():
    v137 = eq v123, v3
    jmpif v137 then: b16, else: b17
  b16():
    store u1 1 at v134
    jmp b17()
  b17():
    jmp b19()
}

After `static_assert` and `assert_constant`:
brillig fn main f0 {
  b0(v0: [Field, Field; 6]):
    v2 = array_get v0, index u32 0
    v4 = array_get v0, index u32 1
    v5 = array_get v0, index u32 0
    v6 = array_get v0, index u32 1
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    v10 = allocate
    store u32 1 at v10
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    v11 = allocate
    store [u1 0, Field 0, Field 0, u1 0] at v11
    v12 = allocate
    store u32 0 at v12
    call f1(v10, v11, v12, v2, v6)
    constrain u32 0 == u32 1 '"UHashMap after one insert should have a length of 1 element."'
    return 
}
brillig fn insert f1 {
  b0(v0: &mut u32, v1: &mut [u1, Field, Field, u1], v2: &mut u32, v3: Field, v4: Field):
    v12 = load v1
    inc_rc v12
    inc_rc v12
    v13 = load v0
    v14 = load v2
    v16 = add v14, u32 1
    v18 = div v13, u32 2
    v19 = lt v16, v18
    v20 = not v19
    jmpif v20 then: b1, else: b8
  b1():
    v21 = load v0
    v22 = mul v21, u32 2
    v23 = allocate
    store u32 0 at v23
    inc_rc []
    v26 = allocate
    store [] at v26
    jmp b2(u32 0)
  b2(v5: u32):
    v27 = lt v5, v22
    jmpif v27 then: b39, else: b3
  b39():
    v226 = load v23
    v227 = load v26
    v228, v229 = call slice_push_back(v226, v227, u1 0, Field 0, Field 0, u1 0)
    inc_rc v229
    store v228 at v23
    store v229 at v26
    v230 = add v5, u32 1
    jmp b2(v230)
  b3():
    v28 = load v23
    v29 = load v26
    inc_rc v29
    v30 = allocate
    store v28 at v30
    inc_rc v29
    v31 = allocate
    store v29 at v31
    v32 = allocate
    store u32 0 at v32
    v33 = load v0
    v34 = load v1
    v35 = load v2
    v36 = allocate
    store u32 0 at v36
    inc_rc []
    v38 = allocate
    store [] at v38
    inc_rc v34
    jmp b4(u32 0)
  b4(v6: u32):
    v39 = lt v6, v33
    jmpif v39 then: b36, else: b5
  b36():
    v206 = mul v6, u32 4
    v207 = lt v6, v33
    constrain v207 == u1 1 '"Index out of bounds"'
    v208 = array_get v34, index v206
    v209 = add v206, u32 1
    v210 = lt v6, v33
    constrain v210 == u1 1 '"Index out of bounds"'
    v211 = array_get v34, index v209
    v212 = add v206, u32 2
    v213 = lt v6, v33
    constrain v213 == u1 1 '"Index out of bounds"'
    v214 = array_get v34, index v212
    v215 = add v206, u32 3
    v216 = lt v6, v33
    constrain v216 == u1 1 '"Index out of bounds"'
    v217 = array_get v34, index v215
    v218 = not v217
    v219 = mul v218, v208
    jmpif v219 then: b37, else: b38
  b37():
    v220 = load v36
    v221 = load v38
    v223, v224 = call slice_push_back(v220, v221, v211, v214)
    inc_rc v224
    store v223 at v36
    store v224 at v38
    jmp b38()
  b38():
    v225 = add v6, u32 1
    jmp b4(v225)
  b5():
    inc_rc [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46]
    v67 = load v36
    v68 = load v38
    v69 = eq v67, v35
    constrain v67 == v35, data [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46], u32 0
    inc_rc v68
    jmp b6(u32 0)
  b6(v7: u32):
    v70 = lt v7, v67
    jmpif v70 then: b35, else: b7
  b35():
    v198 = mul v7, u32 2
    v199 = lt v7, v67
    constrain v199 == u1 1 '"Index out of bounds"'
    v200 = array_get v68, index v198
    v201 = add v198, u32 1
    v202 = lt v7, v67
    constrain v202 == u1 1 '"Index out of bounds"'
    v203 = array_get v68, index v201
    call f1(v30, v31, v32, v200, v203)
    v205 = add v7, u32 1
    jmp b6(v205)
  b7():
    v71 = load v30
    v72 = load v31
    v73 = load v32
    inc_rc v72
    store v71 at v0
    store v72 at v1
    store v73 at v2
    jmp b8()
  b8():
    v74 = load v1
    dec_rc v74
    inc_rc []
    v76 = allocate
    inc_rc []
    v77 = allocate
    inc_rc []
    inc_rc []
    inc_rc [v3]
    dec_rc [v3]
    dec_rc [v3]
    inc_rc [Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0]
    v82 = allocate
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    v83 = allocate
    v84 = allocate
    v85 = allocate
    inc_rc [Field 0, Field 0, Field 0]
    v86 = allocate
    store [Field 0, Field 0, Field 0] at v86
    inc_rc [Field 0, Field 0, Field 0, Field 2⁶⁴]
    v89 = allocate
    store [Field 0, Field 0, Field 0, Field 2⁶⁴] at v89
    v90 = allocate
    store u32 0 at v90
    v91 = allocate
    store u1 0 at v91
    jmp b9(u32 0)
  b9(v8: u32):
    v93 = eq v8, u32 0
    jmpif v93 then: b26, else: b10
  b26():
    v165 = eq v8, u32 0
    constrain v8 == u32 0 '"Index out of bounds"'
    v166 = array_get [v3], index v8
    v167 = load v86
    inc_rc v167
    v168 = load v89
    inc_rc v168
    v169 = load v90
    v170 = load v91
    v171 = not v170
    constrain v170 == u1 0
    v172 = eq v169, u32 3
    jmpif v172 then: b28, else: b27
  b28():
    v178 = load v86
    inc_rc v178
    v179 = load v89
    inc_rc v179
    jmp b29(u32 0)
  b29(v11: u32):
    v180 = lt v11, u32 3
    jmpif v180 then: b32, else: b30
  b32():
    v188 = load v90
    v189 = lt v11, v188
    jmpif v189 then: b33, else: b34
  b33():
    v190 = load v86
    v191 = load v89
    v192 = array_get v191, index v11
    v193 = array_get v190, index v11
    v194 = add v192, v193
    v195 = array_set v191, index v11, value v194
    v196 = add v11, u32 1
    store v195 at v89
    jmp b34()
  b34():
    v197 = add v11, u32 1
    jmp b29(v197)
  b30():
    v181 = load v86
    v182 = load v89
    v183 = call poseidon2_permutation(v182, u32 4)
    inc_rc v183
    dec_rc v181
    dec_rc v183
    v184 = array_set v181, index u32 0, value v166
    store v184 at v86
    store v183 at v89
    store u32 1 at v90
    jmp b31()
  b31():
    v185 = load v86
    dec_rc v185
    v186 = load v89
    dec_rc v186
    v187 = add v8, u32 1
    jmp b9(v187)
  b27():
    v173 = load v86
    v174 = load v90
    v175 = array_set v173, index v174, value v166
    v176 = add v174, u32 1
    v177 = add v174, u32 1
    store v175 at v86
    store v177 at v90
    jmp b31()
  b10():
    v94 = load v86
    inc_rc v94
    v95 = load v89
    inc_rc v95
    v96 = load v91
    v97 = not v96
    constrain v96 == u1 0
    inc_rc v94
    inc_rc v95
    jmp b11(u32 0)
  b11(v9: u32):
    v99 = lt v9, u32 3
    jmpif v99 then: b23, else: b12
  b23():
    v155 = load v90
    v156 = lt v9, v155
    jmpif v156 then: b24, else: b25
  b24():
    v157 = load v86
    v158 = load v89
    v159 = array_get v158, index v9
    v160 = array_get v157, index v9
    v161 = add v159, v160
    v162 = array_set v158, index v9, value v161
    v163 = add v9, u32 1
    store v162 at v89
    jmp b25()
  b25():
    v164 = add v9, u32 1
    jmp b11(v164)
  b12():
    v100 = load v86
    v101 = load v89
    v104 = call poseidon2_permutation(v101, u32 4)
    inc_rc v104
    dec_rc v100
    dec_rc v104
    store v104 at v89
    store u1 1 at v91
    v106 = array_get v104, index u32 0
    dec_rc v100
    dec_rc v104
    v107 = truncate v106 to 32 bits, max_bit_size: 254
    v108 = cast v107 as u32
    v109 = load v0
    jmp b13(u32 0)
  b13(v10: u32):
    v110 = lt v10, v109
    jmpif v110 then: b14, else: b22
  b14():
    v111 = load v0
    v112 = load v1
    v113 = mul v10, v10
    v114 = add v10, v113
    v115 = div v114, u32 2
    v116 = add v108, v115
    v117 = mod v116, v111
    v118 = mul v117, u32 4
    v119 = lt v117, v111
    constrain v119 == u1 1 '"Index out of bounds"'
    v120 = array_get v112, index v118
    v121 = add v118, u32 1
    v122 = lt v117, v111
    constrain v122 == u1 1 '"Index out of bounds"'
    v123 = array_get v112, index v121
    v124 = add v118, u32 2
    v125 = lt v117, v111
    constrain v125 == u1 1 '"Index out of bounds"'
    v126 = array_get v112, index v124
    v127 = add v118, u32 3
    v128 = lt v117, v111
    constrain v128 == u1 1 '"Index out of bounds"'
    v129 = array_get v112, index v127
    v130 = allocate
    v131 = allocate
    v132 = allocate
    v133 = allocate
    v134 = allocate
    store u1 0 at v134
    v135 = not v120
    v136 = or v129, v135
    jmpif v136 then: b18, else: b15
  b18():
    store u1 1 at v134
    v138 = load v1
    v139 = load v2
    v140 = add v139, u32 1
    store v138 at v1
    store v140 at v2
    jmp b19()
  b19():
    v141 = load v134
    jmpif v141 then: b21, else: b20
  b21():
    store u1 1 at v130
    store v3 at v131
    store v4 at v132
    store u1 0 at v133
    v143 = load v1
    v144 = load v2
    v145 = mul v117, u32 4
    v146 = array_set v143, index v145, value u1 1
    v147 = add v145, u32 1
    v148 = array_set v146, index v147, value v3
    v149 = add v147, u32 1
    v150 = array_set v148, index v149, value v4
    v151 = add v149, u32 1
    v152 = array_set v150, index v151, value u1 0
    v153 = add v151, u32 1
    store v152 at v1
    store v144 at v2
    jmp b22()
  b22():
    v154 = load v1
    dec_rc v154
    return 
  b20():
    v142 = add v10, u32 1
    jmp b13(v142)
  b15():
    v137 = eq v123, v3
    jmpif v137 then: b16, else: b17
  b16():
    store u1 1 at v134
    jmp b17()
  b17():
    jmp b19()
}

After Unrolling:
brillig fn main f0 {
  b0(v0: [Field, Field; 6]):
    v2 = array_get v0, index u32 0
    v4 = array_get v0, index u32 1
    v5 = array_get v0, index u32 0
    v6 = array_get v0, index u32 1
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    v10 = allocate
    store u32 1 at v10
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    v11 = allocate
    store [u1 0, Field 0, Field 0, u1 0] at v11
    v12 = allocate
    store u32 0 at v12
    call f1(v10, v11, v12, v2, v6)
    constrain u32 0 == u32 1 '"UHashMap after one insert should have a length of 1 element."'
    return 
}
brillig fn insert f1 {
  b0(v0: &mut u32, v1: &mut [u1, Field, Field, u1], v2: &mut u32, v3: Field, v4: Field):
    v12 = load v1
    inc_rc v12
    inc_rc v12
    v13 = load v0
    v14 = load v2
    v16 = add v14, u32 1
    v18 = div v13, u32 2
    v19 = lt v16, v18
    v20 = not v19
    jmpif v20 then: b1, else: b8
  b1():
    v21 = load v0
    v22 = mul v21, u32 2
    v23 = allocate
    store u32 0 at v23
    inc_rc []
    v26 = allocate
    store [] at v26
    jmp b2(u32 0)
  b2(v5: u32):
    v27 = lt v5, v22
    jmpif v27 then: b39, else: b3
  b39():
    v226 = load v23
    v227 = load v26
    v228, v229 = call slice_push_back(v226, v227, u1 0, Field 0, Field 0, u1 0)
    inc_rc v229
    store v228 at v23
    store v229 at v26
    v230 = add v5, u32 1
    jmp b2(v230)
  b3():
    v28 = load v23
    v29 = load v26
    inc_rc v29
    v30 = allocate
    store v28 at v30
    inc_rc v29
    v31 = allocate
    store v29 at v31
    v32 = allocate
    store u32 0 at v32
    v33 = load v0
    v34 = load v1
    v35 = load v2
    v36 = allocate
    store u32 0 at v36
    inc_rc []
    v38 = allocate
    store [] at v38
    inc_rc v34
    jmp b4(u32 0)
  b4(v6: u32):
    v39 = lt v6, v33
    jmpif v39 then: b36, else: b5
  b36():
    v206 = mul v6, u32 4
    v207 = lt v6, v33
    constrain v207 == u1 1 '"Index out of bounds"'
    v208 = array_get v34, index v206
    v209 = add v206, u32 1
    v210 = lt v6, v33
    constrain v210 == u1 1 '"Index out of bounds"'
    v211 = array_get v34, index v209
    v212 = add v206, u32 2
    v213 = lt v6, v33
    constrain v213 == u1 1 '"Index out of bounds"'
    v214 = array_get v34, index v212
    v215 = add v206, u32 3
    v216 = lt v6, v33
    constrain v216 == u1 1 '"Index out of bounds"'
    v217 = array_get v34, index v215
    v218 = not v217
    v219 = mul v218, v208
    jmpif v219 then: b37, else: b38
  b37():
    v220 = load v36
    v221 = load v38
    v223, v224 = call slice_push_back(v220, v221, v211, v214)
    inc_rc v224
    store v223 at v36
    store v224 at v38
    jmp b38()
  b38():
    v225 = add v6, u32 1
    jmp b4(v225)
  b5():
    inc_rc [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46]
    v67 = load v36
    v68 = load v38
    v69 = eq v67, v35
    constrain v67 == v35, data [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46], u32 0
    inc_rc v68
    jmp b6(u32 0)
  b6(v7: u32):
    v70 = lt v7, v67
    jmpif v70 then: b35, else: b7
  b35():
    v198 = mul v7, u32 2
    v199 = lt v7, v67
    constrain v199 == u1 1 '"Index out of bounds"'
    v200 = array_get v68, index v198
    v201 = add v198, u32 1
    v202 = lt v7, v67
    constrain v202 == u1 1 '"Index out of bounds"'
    v203 = array_get v68, index v201
    call f1(v30, v31, v32, v200, v203)
    v205 = add v7, u32 1
    jmp b6(v205)
  b7():
    v71 = load v30
    v72 = load v31
    v73 = load v32
    inc_rc v72
    store v71 at v0
    store v72 at v1
    store v73 at v2
    jmp b8()
  b8():
    v74 = load v1
    dec_rc v74
    inc_rc []
    v76 = allocate
    inc_rc []
    v77 = allocate
    inc_rc []
    inc_rc []
    inc_rc [v3]
    dec_rc [v3]
    dec_rc [v3]
    inc_rc [Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0]
    v82 = allocate
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    v83 = allocate
    v84 = allocate
    v85 = allocate
    inc_rc [Field 0, Field 0, Field 0]
    v86 = allocate
    store [Field 0, Field 0, Field 0] at v86
    inc_rc [Field 0, Field 0, Field 0, Field 2⁶⁴]
    v89 = allocate
    store [Field 0, Field 0, Field 0, Field 2⁶⁴] at v89
    v90 = allocate
    store u32 0 at v90
    v91 = allocate
    store u1 0 at v91
    jmp b9(u32 0)
  b9(v8: u32):
    v93 = eq v8, u32 0
    jmpif v93 then: b26, else: b10
  b26():
    v165 = eq v8, u32 0
    constrain v8 == u32 0 '"Index out of bounds"'
    v166 = array_get [v3], index v8
    v167 = load v86
    inc_rc v167
    v168 = load v89
    inc_rc v168
    v169 = load v90
    v170 = load v91
    v171 = not v170
    constrain v170 == u1 0
    v172 = eq v169, u32 3
    jmpif v172 then: b28, else: b27
  b28():
    v178 = load v86
    inc_rc v178
    v179 = load v89
    inc_rc v179
    jmp b29(u32 0)
  b29(v11: u32):
    v180 = lt v11, u32 3
    jmpif v180 then: b32, else: b30
  b32():
    v188 = load v90
    v189 = lt v11, v188
    jmpif v189 then: b33, else: b34
  b33():
    v190 = load v86
    v191 = load v89
    v192 = array_get v191, index v11
    v193 = array_get v190, index v11
    v194 = add v192, v193
    v195 = array_set v191, index v11, value v194
    v196 = add v11, u32 1
    store v195 at v89
    jmp b34()
  b34():
    v197 = add v11, u32 1
    jmp b29(v197)
  b30():
    v181 = load v86
    v182 = load v89
    v183 = call poseidon2_permutation(v182, u32 4)
    inc_rc v183
    dec_rc v181
    dec_rc v183
    v184 = array_set v181, index u32 0, value v166
    store v184 at v86
    store v183 at v89
    store u32 1 at v90
    jmp b31()
  b31():
    v185 = load v86
    dec_rc v185
    v186 = load v89
    dec_rc v186
    v187 = add v8, u32 1
    jmp b9(v187)
  b27():
    v173 = load v86
    v174 = load v90
    v175 = array_set v173, index v174, value v166
    v176 = add v174, u32 1
    v177 = add v174, u32 1
    store v175 at v86
    store v177 at v90
    jmp b31()
  b10():
    v94 = load v86
    inc_rc v94
    v95 = load v89
    inc_rc v95
    v96 = load v91
    v97 = not v96
    constrain v96 == u1 0
    inc_rc v94
    inc_rc v95
    jmp b11(u32 0)
  b11(v9: u32):
    v99 = lt v9, u32 3
    jmpif v99 then: b23, else: b12
  b23():
    v155 = load v90
    v156 = lt v9, v155
    jmpif v156 then: b24, else: b25
  b24():
    v157 = load v86
    v158 = load v89
    v159 = array_get v158, index v9
    v160 = array_get v157, index v9
    v161 = add v159, v160
    v162 = array_set v158, index v9, value v161
    v163 = add v9, u32 1
    store v162 at v89
    jmp b25()
  b25():
    v164 = add v9, u32 1
    jmp b11(v164)
  b12():
    v100 = load v86
    v101 = load v89
    v104 = call poseidon2_permutation(v101, u32 4)
    inc_rc v104
    dec_rc v100
    dec_rc v104
    store v104 at v89
    store u1 1 at v91
    v106 = array_get v104, index u32 0
    dec_rc v100
    dec_rc v104
    v107 = truncate v106 to 32 bits, max_bit_size: 254
    v108 = cast v107 as u32
    v109 = load v0
    jmp b13(u32 0)
  b13(v10: u32):
    v110 = lt v10, v109
    jmpif v110 then: b14, else: b22
  b14():
    v111 = load v0
    v112 = load v1
    v113 = mul v10, v10
    v114 = add v10, v113
    v115 = div v114, u32 2
    v116 = add v108, v115
    v117 = mod v116, v111
    v118 = mul v117, u32 4
    v119 = lt v117, v111
    constrain v119 == u1 1 '"Index out of bounds"'
    v120 = array_get v112, index v118
    v121 = add v118, u32 1
    v122 = lt v117, v111
    constrain v122 == u1 1 '"Index out of bounds"'
    v123 = array_get v112, index v121
    v124 = add v118, u32 2
    v125 = lt v117, v111
    constrain v125 == u1 1 '"Index out of bounds"'
    v126 = array_get v112, index v124
    v127 = add v118, u32 3
    v128 = lt v117, v111
    constrain v128 == u1 1 '"Index out of bounds"'
    v129 = array_get v112, index v127
    v130 = allocate
    v131 = allocate
    v132 = allocate
    v133 = allocate
    v134 = allocate
    store u1 0 at v134
    v135 = not v120
    v136 = or v129, v135
    jmpif v136 then: b18, else: b15
  b18():
    store u1 1 at v134
    v138 = load v1
    v139 = load v2
    v140 = add v139, u32 1
    store v138 at v1
    store v140 at v2
    jmp b19()
  b19():
    v141 = load v134
    jmpif v141 then: b21, else: b20
  b21():
    store u1 1 at v130
    store v3 at v131
    store v4 at v132
    store u1 0 at v133
    v143 = load v1
    v144 = load v2
    v145 = mul v117, u32 4
    v146 = array_set v143, index v145, value u1 1
    v147 = add v145, u32 1
    v148 = array_set v146, index v147, value v3
    v149 = add v147, u32 1
    v150 = array_set v148, index v149, value v4
    v151 = add v149, u32 1
    v152 = array_set v150, index v151, value u1 0
    v153 = add v151, u32 1
    store v152 at v1
    store v144 at v2
    jmp b22()
  b22():
    v154 = load v1
    dec_rc v154
    return 
  b20():
    v142 = add v10, u32 1
    jmp b13(v142)
  b15():
    v137 = eq v123, v3
    jmpif v137 then: b16, else: b17
  b16():
    store u1 1 at v134
    jmp b17()
  b17():
    jmp b19()
}

After Simplifying:
brillig fn main f0 {
  b0(v0: [Field, Field; 6]):
    v2 = array_get v0, index u32 0
    v4 = array_get v0, index u32 1
    v5 = array_get v0, index u32 0
    v6 = array_get v0, index u32 1
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    v10 = allocate
    store u32 1 at v10
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    v11 = allocate
    store [u1 0, Field 0, Field 0, u1 0] at v11
    v12 = allocate
    store u32 0 at v12
    call f1(v10, v11, v12, v2, v6)
    constrain u32 0 == u32 1 '"UHashMap after one insert should have a length of 1 element."'
    return 
}
brillig fn insert f1 {
  b0(v0: &mut u32, v1: &mut [u1, Field, Field, u1], v2: &mut u32, v3: Field, v4: Field):
    v12 = load v1
    inc_rc v12
    inc_rc v12
    v13 = load v0
    v14 = load v2
    v16 = add v14, u32 1
    v18 = div v13, u32 2
    v19 = lt v16, v18
    v20 = not v19
    jmpif v20 then: b1, else: b8
  b1():
    v21 = load v0
    v22 = mul v21, u32 2
    v23 = allocate
    store u32 0 at v23
    inc_rc []
    v26 = allocate
    store [] at v26
    jmp b2(u32 0)
  b2(v5: u32):
    v27 = lt v5, v22
    jmpif v27 then: b38, else: b3
  b38():
    v226 = load v23
    v227 = load v26
    v228, v229 = call slice_push_back(v226, v227, u1 0, Field 0, Field 0, u1 0)
    inc_rc v229
    store v228 at v23
    store v229 at v26
    v230 = add v5, u32 1
    jmp b2(v230)
  b3():
    v28 = load v23
    v29 = load v26
    inc_rc v29
    v30 = allocate
    store v28 at v30
    inc_rc v29
    v31 = allocate
    store v29 at v31
    v32 = allocate
    store u32 0 at v32
    v33 = load v0
    v34 = load v1
    v35 = load v2
    v36 = allocate
    store u32 0 at v36
    inc_rc []
    v38 = allocate
    store [] at v38
    inc_rc v34
    jmp b4(u32 0)
  b4(v6: u32):
    v39 = lt v6, v33
    jmpif v39 then: b35, else: b5
  b35():
    v206 = mul v6, u32 4
    v207 = lt v6, v33
    constrain v207 == u1 1 '"Index out of bounds"'
    v208 = array_get v34, index v206
    v209 = add v206, u32 1
    v210 = lt v6, v33
    constrain v210 == u1 1 '"Index out of bounds"'
    v211 = array_get v34, index v209
    v212 = add v206, u32 2
    v213 = lt v6, v33
    constrain v213 == u1 1 '"Index out of bounds"'
    v214 = array_get v34, index v212
    v215 = add v206, u32 3
    v216 = lt v6, v33
    constrain v216 == u1 1 '"Index out of bounds"'
    v217 = array_get v34, index v215
    v218 = not v217
    v219 = mul v218, v208
    jmpif v219 then: b36, else: b37
  b36():
    v220 = load v36
    v221 = load v38
    v223, v224 = call slice_push_back(v220, v221, v211, v214)
    inc_rc v224
    store v223 at v36
    store v224 at v38
    jmp b37()
  b37():
    v225 = add v6, u32 1
    jmp b4(v225)
  b5():
    inc_rc [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46]
    v67 = load v36
    v68 = load v38
    v69 = eq v67, v35
    constrain v67 == v35, data [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46], u32 0
    inc_rc v68
    jmp b6(u32 0)
  b6(v7: u32):
    v70 = lt v7, v67
    jmpif v70 then: b34, else: b7
  b34():
    v198 = mul v7, u32 2
    v199 = lt v7, v67
    constrain v199 == u1 1 '"Index out of bounds"'
    v200 = array_get v68, index v198
    v201 = add v198, u32 1
    v202 = lt v7, v67
    constrain v202 == u1 1 '"Index out of bounds"'
    v203 = array_get v68, index v201
    call f1(v30, v31, v32, v200, v203)
    v205 = add v7, u32 1
    jmp b6(v205)
  b7():
    v71 = load v30
    v72 = load v31
    v73 = load v32
    inc_rc v72
    store v71 at v0
    store v72 at v1
    store v73 at v2
    jmp b8()
  b8():
    v74 = load v1
    dec_rc v74
    inc_rc []
    v76 = allocate
    inc_rc []
    v77 = allocate
    inc_rc []
    inc_rc []
    inc_rc [v3]
    dec_rc [v3]
    dec_rc [v3]
    inc_rc [Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0]
    v82 = allocate
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    v83 = allocate
    v84 = allocate
    v85 = allocate
    inc_rc [Field 0, Field 0, Field 0]
    v86 = allocate
    store [Field 0, Field 0, Field 0] at v86
    inc_rc [Field 0, Field 0, Field 0, Field 2⁶⁴]
    v89 = allocate
    store [Field 0, Field 0, Field 0, Field 2⁶⁴] at v89
    v90 = allocate
    store u32 0 at v90
    v91 = allocate
    store u1 0 at v91
    jmp b9(u32 0)
  b9(v8: u32):
    v93 = eq v8, u32 0
    jmpif v93 then: b25, else: b10
  b25():
    v165 = eq v8, u32 0
    constrain v8 == u32 0 '"Index out of bounds"'
    v166 = array_get [v3], index v8
    v167 = load v86
    inc_rc v167
    v168 = load v89
    inc_rc v168
    v169 = load v90
    v170 = load v91
    v171 = not v170
    constrain v170 == u1 0
    v172 = eq v169, u32 3
    jmpif v172 then: b27, else: b26
  b27():
    v178 = load v86
    inc_rc v178
    v179 = load v89
    inc_rc v179
    jmp b28(u32 0)
  b28(v11: u32):
    v180 = lt v11, u32 3
    jmpif v180 then: b31, else: b29
  b31():
    v188 = load v90
    v189 = lt v11, v188
    jmpif v189 then: b32, else: b33
  b32():
    v190 = load v86
    v191 = load v89
    v192 = array_get v191, index v11
    v193 = array_get v190, index v11
    v194 = add v192, v193
    v195 = array_set v191, index v11, value v194
    v196 = add v11, u32 1
    store v195 at v89
    jmp b33()
  b33():
    v197 = add v11, u32 1
    jmp b28(v197)
  b29():
    v181 = load v86
    v182 = load v89
    v183 = call poseidon2_permutation(v182, u32 4)
    inc_rc v183
    dec_rc v181
    dec_rc v183
    v184 = array_set v181, index u32 0, value v166
    store v184 at v86
    store v183 at v89
    store u32 1 at v90
    jmp b30()
  b30():
    v185 = load v86
    dec_rc v185
    v186 = load v89
    dec_rc v186
    v187 = add v8, u32 1
    jmp b9(v187)
  b26():
    v173 = load v86
    v174 = load v90
    v175 = array_set v173, index v174, value v166
    v176 = add v174, u32 1
    v177 = add v174, u32 1
    store v175 at v86
    store v177 at v90
    jmp b30()
  b10():
    v94 = load v86
    inc_rc v94
    v95 = load v89
    inc_rc v95
    v96 = load v91
    v97 = not v96
    constrain v96 == u1 0
    inc_rc v94
    inc_rc v95
    jmp b11(u32 0)
  b11(v9: u32):
    v99 = lt v9, u32 3
    jmpif v99 then: b22, else: b12
  b22():
    v155 = load v90
    v156 = lt v9, v155
    jmpif v156 then: b23, else: b24
  b23():
    v157 = load v86
    v158 = load v89
    v159 = array_get v158, index v9
    v160 = array_get v157, index v9
    v161 = add v159, v160
    v162 = array_set v158, index v9, value v161
    v163 = add v9, u32 1
    store v162 at v89
    jmp b24()
  b24():
    v164 = add v9, u32 1
    jmp b11(v164)
  b12():
    v100 = load v86
    v101 = load v89
    v104 = call poseidon2_permutation(v101, u32 4)
    inc_rc v104
    dec_rc v100
    dec_rc v104
    store v104 at v89
    store u1 1 at v91
    v106 = array_get v104, index u32 0
    dec_rc v100
    dec_rc v104
    v107 = truncate v106 to 32 bits, max_bit_size: 254
    v108 = cast v107 as u32
    v109 = load v0
    jmp b13(u32 0)
  b13(v10: u32):
    v110 = lt v10, v109
    jmpif v110 then: b14, else: b21
  b14():
    v111 = load v0
    v112 = load v1
    v113 = mul v10, v10
    v114 = add v10, v113
    v115 = div v114, u32 2
    v116 = add v108, v115
    v117 = mod v116, v111
    v118 = mul v117, u32 4
    v119 = lt v117, v111
    constrain v119 == u1 1 '"Index out of bounds"'
    v120 = array_get v112, index v118
    v121 = add v118, u32 1
    v122 = lt v117, v111
    constrain v122 == u1 1 '"Index out of bounds"'
    v123 = array_get v112, index v121
    v124 = add v118, u32 2
    v125 = lt v117, v111
    constrain v125 == u1 1 '"Index out of bounds"'
    v126 = array_get v112, index v124
    v127 = add v118, u32 3
    v128 = lt v117, v111
    constrain v128 == u1 1 '"Index out of bounds"'
    v129 = array_get v112, index v127
    v130 = allocate
    v131 = allocate
    v132 = allocate
    v133 = allocate
    v134 = allocate
    store u1 0 at v134
    v135 = not v120
    v136 = or v129, v135
    jmpif v136 then: b17, else: b15
  b17():
    store u1 1 at v134
    v138 = load v1
    v139 = load v2
    v140 = add v139, u32 1
    store v138 at v1
    store v140 at v2
    jmp b18()
  b18():
    v141 = load v134
    jmpif v141 then: b20, else: b19
  b20():
    store u1 1 at v130
    store v3 at v131
    store v4 at v132
    store u1 0 at v133
    v143 = load v1
    v144 = load v2
    v145 = mul v117, u32 4
    v146 = array_set v143, index v145, value u1 1
    v147 = add v145, u32 1
    v148 = array_set v146, index v147, value v3
    v149 = add v147, u32 1
    v150 = array_set v148, index v149, value v4
    v151 = add v149, u32 1
    v152 = array_set v150, index v151, value u1 0
    v153 = add v151, u32 1
    store v152 at v1
    store v144 at v2
    jmp b21()
  b21():
    v154 = load v1
    dec_rc v154
    return 
  b19():
    v142 = add v10, u32 1
    jmp b13(v142)
  b15():
    v137 = eq v123, v3
    jmpif v137 then: b16, else: b18
  b16():
    store u1 1 at v134
    jmp b18()
}

After Flattening:
brillig fn main f0 {
  b0(v0: [Field, Field; 6]):
    v2 = array_get v0, index u32 0
    v4 = array_get v0, index u32 1
    v5 = array_get v0, index u32 0
    v6 = array_get v0, index u32 1
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    v10 = allocate
    store u32 1 at v10
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    v11 = allocate
    store [u1 0, Field 0, Field 0, u1 0] at v11
    v12 = allocate
    store u32 0 at v12
    call f1(v10, v11, v12, v2, v6)
    constrain u32 0 == u32 1 '"UHashMap after one insert should have a length of 1 element."'
    return 
}
brillig fn insert f1 {
  b0(v0: &mut u32, v1: &mut [u1, Field, Field, u1], v2: &mut u32, v3: Field, v4: Field):
    v12 = load v1
    inc_rc v12
    inc_rc v12
    v13 = load v0
    v14 = load v2
    v16 = add v14, u32 1
    v18 = div v13, u32 2
    v19 = lt v16, v18
    v20 = not v19
    jmpif v20 then: b1, else: b8
  b1():
    v21 = load v0
    v22 = mul v21, u32 2
    v23 = allocate
    store u32 0 at v23
    inc_rc []
    v26 = allocate
    store [] at v26
    jmp b2(u32 0)
  b2(v5: u32):
    v27 = lt v5, v22
    jmpif v27 then: b38, else: b3
  b38():
    v226 = load v23
    v227 = load v26
    v228, v229 = call slice_push_back(v226, v227, u1 0, Field 0, Field 0, u1 0)
    inc_rc v229
    store v228 at v23
    store v229 at v26
    v230 = add v5, u32 1
    jmp b2(v230)
  b3():
    v28 = load v23
    v29 = load v26
    inc_rc v29
    v30 = allocate
    store v28 at v30
    inc_rc v29
    v31 = allocate
    store v29 at v31
    v32 = allocate
    store u32 0 at v32
    v33 = load v0
    v34 = load v1
    v35 = load v2
    v36 = allocate
    store u32 0 at v36
    inc_rc []
    v38 = allocate
    store [] at v38
    inc_rc v34
    jmp b4(u32 0)
  b4(v6: u32):
    v39 = lt v6, v33
    jmpif v39 then: b35, else: b5
  b35():
    v206 = mul v6, u32 4
    v207 = lt v6, v33
    constrain v207 == u1 1 '"Index out of bounds"'
    v208 = array_get v34, index v206
    v209 = add v206, u32 1
    v210 = lt v6, v33
    constrain v210 == u1 1 '"Index out of bounds"'
    v211 = array_get v34, index v209
    v212 = add v206, u32 2
    v213 = lt v6, v33
    constrain v213 == u1 1 '"Index out of bounds"'
    v214 = array_get v34, index v212
    v215 = add v206, u32 3
    v216 = lt v6, v33
    constrain v216 == u1 1 '"Index out of bounds"'
    v217 = array_get v34, index v215
    v218 = not v217
    v219 = mul v218, v208
    jmpif v219 then: b36, else: b37
  b36():
    v220 = load v36
    v221 = load v38
    v223, v224 = call slice_push_back(v220, v221, v211, v214)
    inc_rc v224
    store v223 at v36
    store v224 at v38
    jmp b37()
  b37():
    v225 = add v6, u32 1
    jmp b4(v225)
  b5():
    inc_rc [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46]
    v67 = load v36
    v68 = load v38
    v69 = eq v67, v35
    constrain v67 == v35, data [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46], u32 0
    inc_rc v68
    jmp b6(u32 0)
  b6(v7: u32):
    v70 = lt v7, v67
    jmpif v70 then: b34, else: b7
  b34():
    v198 = mul v7, u32 2
    v199 = lt v7, v67
    constrain v199 == u1 1 '"Index out of bounds"'
    v200 = array_get v68, index v198
    v201 = add v198, u32 1
    v202 = lt v7, v67
    constrain v202 == u1 1 '"Index out of bounds"'
    v203 = array_get v68, index v201
    call f1(v30, v31, v32, v200, v203)
    v205 = add v7, u32 1
    jmp b6(v205)
  b7():
    v71 = load v30
    v72 = load v31
    v73 = load v32
    inc_rc v72
    store v71 at v0
    store v72 at v1
    store v73 at v2
    jmp b8()
  b8():
    v74 = load v1
    dec_rc v74
    inc_rc []
    v76 = allocate
    inc_rc []
    v77 = allocate
    inc_rc []
    inc_rc []
    inc_rc [v3]
    dec_rc [v3]
    dec_rc [v3]
    inc_rc [Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0]
    v82 = allocate
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    v83 = allocate
    v84 = allocate
    v85 = allocate
    inc_rc [Field 0, Field 0, Field 0]
    v86 = allocate
    store [Field 0, Field 0, Field 0] at v86
    inc_rc [Field 0, Field 0, Field 0, Field 2⁶⁴]
    v89 = allocate
    store [Field 0, Field 0, Field 0, Field 2⁶⁴] at v89
    v90 = allocate
    store u32 0 at v90
    v91 = allocate
    store u1 0 at v91
    jmp b9(u32 0)
  b9(v8: u32):
    v93 = eq v8, u32 0
    jmpif v93 then: b25, else: b10
  b25():
    v165 = eq v8, u32 0
    constrain v8 == u32 0 '"Index out of bounds"'
    v166 = array_get [v3], index v8
    v167 = load v86
    inc_rc v167
    v168 = load v89
    inc_rc v168
    v169 = load v90
    v170 = load v91
    v171 = not v170
    constrain v170 == u1 0
    v172 = eq v169, u32 3
    jmpif v172 then: b27, else: b26
  b27():
    v178 = load v86
    inc_rc v178
    v179 = load v89
    inc_rc v179
    jmp b28(u32 0)
  b28(v11: u32):
    v180 = lt v11, u32 3
    jmpif v180 then: b31, else: b29
  b31():
    v188 = load v90
    v189 = lt v11, v188
    jmpif v189 then: b32, else: b33
  b32():
    v190 = load v86
    v191 = load v89
    v192 = array_get v191, index v11
    v193 = array_get v190, index v11
    v194 = add v192, v193
    v195 = array_set v191, index v11, value v194
    v196 = add v11, u32 1
    store v195 at v89
    jmp b33()
  b33():
    v197 = add v11, u32 1
    jmp b28(v197)
  b29():
    v181 = load v86
    v182 = load v89
    v183 = call poseidon2_permutation(v182, u32 4)
    inc_rc v183
    dec_rc v181
    dec_rc v183
    v184 = array_set v181, index u32 0, value v166
    store v184 at v86
    store v183 at v89
    store u32 1 at v90
    jmp b30()
  b30():
    v185 = load v86
    dec_rc v185
    v186 = load v89
    dec_rc v186
    v187 = add v8, u32 1
    jmp b9(v187)
  b26():
    v173 = load v86
    v174 = load v90
    v175 = array_set v173, index v174, value v166
    v176 = add v174, u32 1
    v177 = add v174, u32 1
    store v175 at v86
    store v177 at v90
    jmp b30()
  b10():
    v94 = load v86
    inc_rc v94
    v95 = load v89
    inc_rc v95
    v96 = load v91
    v97 = not v96
    constrain v96 == u1 0
    inc_rc v94
    inc_rc v95
    jmp b11(u32 0)
  b11(v9: u32):
    v99 = lt v9, u32 3
    jmpif v99 then: b22, else: b12
  b22():
    v155 = load v90
    v156 = lt v9, v155
    jmpif v156 then: b23, else: b24
  b23():
    v157 = load v86
    v158 = load v89
    v159 = array_get v158, index v9
    v160 = array_get v157, index v9
    v161 = add v159, v160
    v162 = array_set v158, index v9, value v161
    v163 = add v9, u32 1
    store v162 at v89
    jmp b24()
  b24():
    v164 = add v9, u32 1
    jmp b11(v164)
  b12():
    v100 = load v86
    v101 = load v89
    v104 = call poseidon2_permutation(v101, u32 4)
    inc_rc v104
    dec_rc v100
    dec_rc v104
    store v104 at v89
    store u1 1 at v91
    v106 = array_get v104, index u32 0
    dec_rc v100
    dec_rc v104
    v107 = truncate v106 to 32 bits, max_bit_size: 254
    v108 = cast v107 as u32
    v109 = load v0
    jmp b13(u32 0)
  b13(v10: u32):
    v110 = lt v10, v109
    jmpif v110 then: b14, else: b21
  b14():
    v111 = load v0
    v112 = load v1
    v113 = mul v10, v10
    v114 = add v10, v113
    v115 = div v114, u32 2
    v116 = add v108, v115
    v117 = mod v116, v111
    v118 = mul v117, u32 4
    v119 = lt v117, v111
    constrain v119 == u1 1 '"Index out of bounds"'
    v120 = array_get v112, index v118
    v121 = add v118, u32 1
    v122 = lt v117, v111
    constrain v122 == u1 1 '"Index out of bounds"'
    v123 = array_get v112, index v121
    v124 = add v118, u32 2
    v125 = lt v117, v111
    constrain v125 == u1 1 '"Index out of bounds"'
    v126 = array_get v112, index v124
    v127 = add v118, u32 3
    v128 = lt v117, v111
    constrain v128 == u1 1 '"Index out of bounds"'
    v129 = array_get v112, index v127
    v130 = allocate
    v131 = allocate
    v132 = allocate
    v133 = allocate
    v134 = allocate
    store u1 0 at v134
    v135 = not v120
    v136 = or v129, v135
    jmpif v136 then: b17, else: b15
  b17():
    store u1 1 at v134
    v138 = load v1
    v139 = load v2
    v140 = add v139, u32 1
    store v138 at v1
    store v140 at v2
    jmp b18()
  b18():
    v141 = load v134
    jmpif v141 then: b20, else: b19
  b20():
    store u1 1 at v130
    store v3 at v131
    store v4 at v132
    store u1 0 at v133
    v143 = load v1
    v144 = load v2
    v145 = mul v117, u32 4
    v146 = array_set v143, index v145, value u1 1
    v147 = add v145, u32 1
    v148 = array_set v146, index v147, value v3
    v149 = add v147, u32 1
    v150 = array_set v148, index v149, value v4
    v151 = add v149, u32 1
    v152 = array_set v150, index v151, value u1 0
    v153 = add v151, u32 1
    store v152 at v1
    store v144 at v2
    jmp b21()
  b21():
    v154 = load v1
    dec_rc v154
    return 
  b19():
    v142 = add v10, u32 1
    jmp b13(v142)
  b15():
    v137 = eq v123, v3
    jmpif v137 then: b16, else: b18
  b16():
    store u1 1 at v134
    jmp b18()
}

After Removing Bit Shifts:
brillig fn main f0 {
  b0(v0: [Field, Field; 6]):
    v2 = array_get v0, index u32 0
    v4 = array_get v0, index u32 1
    v5 = array_get v0, index u32 0
    v6 = array_get v0, index u32 1
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    v10 = allocate
    store u32 1 at v10
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    v11 = allocate
    store [u1 0, Field 0, Field 0, u1 0] at v11
    v12 = allocate
    store u32 0 at v12
    call f1(v10, v11, v12, v2, v6)
    constrain u32 0 == u32 1 '"UHashMap after one insert should have a length of 1 element."'
    return 
}
brillig fn insert f1 {
  b0(v0: &mut u32, v1: &mut [u1, Field, Field, u1], v2: &mut u32, v3: Field, v4: Field):
    v12 = load v1
    inc_rc v12
    inc_rc v12
    v13 = load v0
    v14 = load v2
    v16 = add v14, u32 1
    v18 = div v13, u32 2
    v19 = lt v16, v18
    v20 = not v19
    jmpif v20 then: b1, else: b8
  b1():
    v21 = load v0
    v22 = mul v21, u32 2
    v23 = allocate
    store u32 0 at v23
    inc_rc []
    v26 = allocate
    store [] at v26
    jmp b2(u32 0)
  b2(v5: u32):
    v27 = lt v5, v22
    jmpif v27 then: b38, else: b3
  b38():
    v226 = load v23
    v227 = load v26
    v228, v229 = call slice_push_back(v226, v227, u1 0, Field 0, Field 0, u1 0)
    inc_rc v229
    store v228 at v23
    store v229 at v26
    v230 = add v5, u32 1
    jmp b2(v230)
  b3():
    v28 = load v23
    v29 = load v26
    inc_rc v29
    v30 = allocate
    store v28 at v30
    inc_rc v29
    v31 = allocate
    store v29 at v31
    v32 = allocate
    store u32 0 at v32
    v33 = load v0
    v34 = load v1
    v35 = load v2
    v36 = allocate
    store u32 0 at v36
    inc_rc []
    v38 = allocate
    store [] at v38
    inc_rc v34
    jmp b4(u32 0)
  b4(v6: u32):
    v39 = lt v6, v33
    jmpif v39 then: b35, else: b5
  b35():
    v206 = mul v6, u32 4
    v207 = lt v6, v33
    constrain v207 == u1 1 '"Index out of bounds"'
    v208 = array_get v34, index v206
    v209 = add v206, u32 1
    v210 = lt v6, v33
    constrain v210 == u1 1 '"Index out of bounds"'
    v211 = array_get v34, index v209
    v212 = add v206, u32 2
    v213 = lt v6, v33
    constrain v213 == u1 1 '"Index out of bounds"'
    v214 = array_get v34, index v212
    v215 = add v206, u32 3
    v216 = lt v6, v33
    constrain v216 == u1 1 '"Index out of bounds"'
    v217 = array_get v34, index v215
    v218 = not v217
    v219 = mul v218, v208
    jmpif v219 then: b36, else: b37
  b36():
    v220 = load v36
    v221 = load v38
    v223, v224 = call slice_push_back(v220, v221, v211, v214)
    inc_rc v224
    store v223 at v36
    store v224 at v38
    jmp b37()
  b37():
    v225 = add v6, u32 1
    jmp b4(v225)
  b5():
    inc_rc [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46]
    v67 = load v36
    v68 = load v38
    v69 = eq v67, v35
    constrain v67 == v35, data [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46], u32 0
    inc_rc v68
    jmp b6(u32 0)
  b6(v7: u32):
    v70 = lt v7, v67
    jmpif v70 then: b34, else: b7
  b34():
    v198 = mul v7, u32 2
    v199 = lt v7, v67
    constrain v199 == u1 1 '"Index out of bounds"'
    v200 = array_get v68, index v198
    v201 = add v198, u32 1
    v202 = lt v7, v67
    constrain v202 == u1 1 '"Index out of bounds"'
    v203 = array_get v68, index v201
    call f1(v30, v31, v32, v200, v203)
    v205 = add v7, u32 1
    jmp b6(v205)
  b7():
    v71 = load v30
    v72 = load v31
    v73 = load v32
    inc_rc v72
    store v71 at v0
    store v72 at v1
    store v73 at v2
    jmp b8()
  b8():
    v74 = load v1
    dec_rc v74
    inc_rc []
    v76 = allocate
    inc_rc []
    v77 = allocate
    inc_rc []
    inc_rc []
    inc_rc [v3]
    dec_rc [v3]
    dec_rc [v3]
    inc_rc [Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0]
    v82 = allocate
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    v83 = allocate
    v84 = allocate
    v85 = allocate
    inc_rc [Field 0, Field 0, Field 0]
    v86 = allocate
    store [Field 0, Field 0, Field 0] at v86
    inc_rc [Field 0, Field 0, Field 0, Field 2⁶⁴]
    v89 = allocate
    store [Field 0, Field 0, Field 0, Field 2⁶⁴] at v89
    v90 = allocate
    store u32 0 at v90
    v91 = allocate
    store u1 0 at v91
    jmp b9(u32 0)
  b9(v8: u32):
    v93 = eq v8, u32 0
    jmpif v93 then: b25, else: b10
  b25():
    v165 = eq v8, u32 0
    constrain v8 == u32 0 '"Index out of bounds"'
    v166 = array_get [v3], index v8
    v167 = load v86
    inc_rc v167
    v168 = load v89
    inc_rc v168
    v169 = load v90
    v170 = load v91
    v171 = not v170
    constrain v170 == u1 0
    v172 = eq v169, u32 3
    jmpif v172 then: b27, else: b26
  b27():
    v178 = load v86
    inc_rc v178
    v179 = load v89
    inc_rc v179
    jmp b28(u32 0)
  b28(v11: u32):
    v180 = lt v11, u32 3
    jmpif v180 then: b31, else: b29
  b31():
    v188 = load v90
    v189 = lt v11, v188
    jmpif v189 then: b32, else: b33
  b32():
    v190 = load v86
    v191 = load v89
    v192 = array_get v191, index v11
    v193 = array_get v190, index v11
    v194 = add v192, v193
    v195 = array_set v191, index v11, value v194
    v196 = add v11, u32 1
    store v195 at v89
    jmp b33()
  b33():
    v197 = add v11, u32 1
    jmp b28(v197)
  b29():
    v181 = load v86
    v182 = load v89
    v183 = call poseidon2_permutation(v182, u32 4)
    inc_rc v183
    dec_rc v181
    dec_rc v183
    v184 = array_set v181, index u32 0, value v166
    store v184 at v86
    store v183 at v89
    store u32 1 at v90
    jmp b30()
  b30():
    v185 = load v86
    dec_rc v185
    v186 = load v89
    dec_rc v186
    v187 = add v8, u32 1
    jmp b9(v187)
  b26():
    v173 = load v86
    v174 = load v90
    v175 = array_set v173, index v174, value v166
    v176 = add v174, u32 1
    v177 = add v174, u32 1
    store v175 at v86
    store v177 at v90
    jmp b30()
  b10():
    v94 = load v86
    inc_rc v94
    v95 = load v89
    inc_rc v95
    v96 = load v91
    v97 = not v96
    constrain v96 == u1 0
    inc_rc v94
    inc_rc v95
    jmp b11(u32 0)
  b11(v9: u32):
    v99 = lt v9, u32 3
    jmpif v99 then: b22, else: b12
  b22():
    v155 = load v90
    v156 = lt v9, v155
    jmpif v156 then: b23, else: b24
  b23():
    v157 = load v86
    v158 = load v89
    v159 = array_get v158, index v9
    v160 = array_get v157, index v9
    v161 = add v159, v160
    v162 = array_set v158, index v9, value v161
    v163 = add v9, u32 1
    store v162 at v89
    jmp b24()
  b24():
    v164 = add v9, u32 1
    jmp b11(v164)
  b12():
    v100 = load v86
    v101 = load v89
    v104 = call poseidon2_permutation(v101, u32 4)
    inc_rc v104
    dec_rc v100
    dec_rc v104
    store v104 at v89
    store u1 1 at v91
    v106 = array_get v104, index u32 0
    dec_rc v100
    dec_rc v104
    v107 = truncate v106 to 32 bits, max_bit_size: 254
    v108 = cast v107 as u32
    v109 = load v0
    jmp b13(u32 0)
  b13(v10: u32):
    v110 = lt v10, v109
    jmpif v110 then: b14, else: b21
  b14():
    v111 = load v0
    v112 = load v1
    v113 = mul v10, v10
    v114 = add v10, v113
    v115 = div v114, u32 2
    v116 = add v108, v115
    v117 = mod v116, v111
    v118 = mul v117, u32 4
    v119 = lt v117, v111
    constrain v119 == u1 1 '"Index out of bounds"'
    v120 = array_get v112, index v118
    v121 = add v118, u32 1
    v122 = lt v117, v111
    constrain v122 == u1 1 '"Index out of bounds"'
    v123 = array_get v112, index v121
    v124 = add v118, u32 2
    v125 = lt v117, v111
    constrain v125 == u1 1 '"Index out of bounds"'
    v126 = array_get v112, index v124
    v127 = add v118, u32 3
    v128 = lt v117, v111
    constrain v128 == u1 1 '"Index out of bounds"'
    v129 = array_get v112, index v127
    v130 = allocate
    v131 = allocate
    v132 = allocate
    v133 = allocate
    v134 = allocate
    store u1 0 at v134
    v135 = not v120
    v136 = or v129, v135
    jmpif v136 then: b17, else: b15
  b17():
    store u1 1 at v134
    v138 = load v1
    v139 = load v2
    v140 = add v139, u32 1
    store v138 at v1
    store v140 at v2
    jmp b18()
  b18():
    v141 = load v134
    jmpif v141 then: b20, else: b19
  b20():
    store u1 1 at v130
    store v3 at v131
    store v4 at v132
    store u1 0 at v133
    v143 = load v1
    v144 = load v2
    v145 = mul v117, u32 4
    v146 = array_set v143, index v145, value u1 1
    v147 = add v145, u32 1
    v148 = array_set v146, index v147, value v3
    v149 = add v147, u32 1
    v150 = array_set v148, index v149, value v4
    v151 = add v149, u32 1
    v152 = array_set v150, index v151, value u1 0
    v153 = add v151, u32 1
    store v152 at v1
    store v144 at v2
    jmp b21()
  b21():
    v154 = load v1
    dec_rc v154
    return 
  b19():
    v142 = add v10, u32 1
    jmp b13(v142)
  b15():
    v137 = eq v123, v3
    jmpif v137 then: b16, else: b18
  b16():
    store u1 1 at v134
    jmp b18()
}

After Mem2Reg:
brillig fn main f0 {
  b0(v0: [Field, Field; 6]):
    v2 = array_get v0, index u32 0
    v4 = array_get v0, index u32 1
    v5 = array_get v0, index u32 0
    v6 = array_get v0, index u32 1
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    v10 = allocate
    store u32 1 at v10
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    v11 = allocate
    store [u1 0, Field 0, Field 0, u1 0] at v11
    v12 = allocate
    store u32 0 at v12
    call f1(v10, v11, v12, v2, v6)
    constrain u32 0 == u32 1 '"UHashMap after one insert should have a length of 1 element."'
    return 
}
brillig fn insert f1 {
  b0(v0: &mut u32, v1: &mut [u1, Field, Field, u1], v2: &mut u32, v3: Field, v4: Field):
    v12 = load v1
    inc_rc v12
    inc_rc v12
    v13 = load v0
    v14 = load v2
    v16 = add v14, u32 1
    v18 = div v13, u32 2
    v19 = lt v16, v18
    v20 = not v19
    jmpif v20 then: b1, else: b8
  b1():
    v21 = load v0
    v22 = mul v21, u32 2
    v23 = allocate
    store u32 0 at v23
    inc_rc []
    v26 = allocate
    store [] at v26
    jmp b2(u32 0)
  b2(v5: u32):
    v27 = lt v5, v22
    jmpif v27 then: b38, else: b3
  b38():
    v225 = load v23
    v226 = load v26
    v227, v228 = call slice_push_back(v225, v226, u1 0, Field 0, Field 0, u1 0)
    inc_rc v228
    store v227 at v23
    store v228 at v26
    v229 = add v5, u32 1
    jmp b2(v229)
  b3():
    v28 = load v23
    v29 = load v26
    inc_rc v29
    v30 = allocate
    store v28 at v30
    inc_rc v29
    v31 = allocate
    store v29 at v31
    v32 = allocate
    store u32 0 at v32
    v33 = load v0
    v34 = load v1
    v35 = load v2
    v36 = allocate
    store u32 0 at v36
    inc_rc []
    v38 = allocate
    store [] at v38
    inc_rc v34
    jmp b4(u32 0)
  b4(v6: u32):
    v39 = lt v6, v33
    jmpif v39 then: b35, else: b5
  b35():
    v205 = mul v6, u32 4
    v206 = lt v6, v33
    constrain v206 == u1 1 '"Index out of bounds"'
    v207 = array_get v34, index v205
    v208 = add v205, u32 1
    v209 = lt v6, v33
    constrain v209 == u1 1 '"Index out of bounds"'
    v210 = array_get v34, index v208
    v211 = add v205, u32 2
    v212 = lt v6, v33
    constrain v212 == u1 1 '"Index out of bounds"'
    v213 = array_get v34, index v211
    v214 = add v205, u32 3
    v215 = lt v6, v33
    constrain v215 == u1 1 '"Index out of bounds"'
    v216 = array_get v34, index v214
    v217 = not v216
    v218 = mul v217, v207
    jmpif v218 then: b36, else: b37
  b36():
    v219 = load v36
    v220 = load v38
    v222, v223 = call slice_push_back(v219, v220, v210, v213)
    inc_rc v223
    store v222 at v36
    store v223 at v38
    jmp b37()
  b37():
    v224 = add v6, u32 1
    jmp b4(v224)
  b5():
    inc_rc [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46]
    v67 = load v36
    v68 = load v38
    v69 = eq v67, v35
    constrain v67 == v35, data [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46], u32 0
    inc_rc v68
    jmp b6(u32 0)
  b6(v7: u32):
    v70 = lt v7, v67
    jmpif v70 then: b34, else: b7
  b34():
    v197 = mul v7, u32 2
    v198 = lt v7, v67
    constrain v198 == u1 1 '"Index out of bounds"'
    v199 = array_get v68, index v197
    v200 = add v197, u32 1
    v201 = lt v7, v67
    constrain v201 == u1 1 '"Index out of bounds"'
    v202 = array_get v68, index v200
    call f1(v30, v31, v32, v199, v202)
    v204 = add v7, u32 1
    jmp b6(v204)
  b7():
    v71 = load v30
    v72 = load v31
    v73 = load v32
    inc_rc v72
    store v71 at v0
    store v72 at v1
    store v73 at v2
    jmp b8()
  b8():
    v74 = load v1
    dec_rc v74
    inc_rc []
    v76 = allocate
    inc_rc []
    v77 = allocate
    inc_rc []
    inc_rc []
    inc_rc [v3]
    dec_rc [v3]
    dec_rc [v3]
    inc_rc [Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0]
    v82 = allocate
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    v83 = allocate
    v84 = allocate
    v85 = allocate
    inc_rc [Field 0, Field 0, Field 0]
    v86 = allocate
    store [Field 0, Field 0, Field 0] at v86
    inc_rc [Field 0, Field 0, Field 0, Field 2⁶⁴]
    v89 = allocate
    store [Field 0, Field 0, Field 0, Field 2⁶⁴] at v89
    v90 = allocate
    store u32 0 at v90
    v91 = allocate
    store u1 0 at v91
    jmp b9(u32 0)
  b9(v8: u32):
    v93 = eq v8, u32 0
    jmpif v93 then: b25, else: b10
  b25():
    v164 = eq v8, u32 0
    constrain v8 == u32 0 '"Index out of bounds"'
    v165 = array_get [v3], index v8
    v166 = load v86
    inc_rc v166
    v167 = load v89
    inc_rc v167
    v168 = load v90
    v169 = load v91
    v170 = not v169
    constrain v169 == u1 0
    v171 = eq v168, u32 3
    jmpif v171 then: b27, else: b26
  b27():
    v177 = load v86
    inc_rc v177
    v178 = load v89
    inc_rc v178
    jmp b28(u32 0)
  b28(v11: u32):
    v179 = lt v11, u32 3
    jmpif v179 then: b31, else: b29
  b31():
    v187 = load v90
    v188 = lt v11, v187
    jmpif v188 then: b32, else: b33
  b32():
    v189 = load v86
    v190 = load v89
    v191 = array_get v190, index v11
    v192 = array_get v189, index v11
    v193 = add v191, v192
    v194 = array_set v190, index v11, value v193
    v195 = add v11, u32 1
    store v194 at v89
    jmp b33()
  b33():
    v196 = add v11, u32 1
    jmp b28(v196)
  b29():
    v180 = load v86
    v181 = load v89
    v182 = call poseidon2_permutation(v181, u32 4)
    inc_rc v182
    dec_rc v180
    dec_rc v182
    v183 = array_set v180, index u32 0, value v165
    store v183 at v86
    store v182 at v89
    store u32 1 at v90
    jmp b30()
  b30():
    v184 = load v86
    dec_rc v184
    v185 = load v89
    dec_rc v185
    v186 = add v8, u32 1
    jmp b9(v186)
  b26():
    v172 = load v86
    v173 = load v90
    v174 = array_set v172, index v173, value v165
    v175 = add v173, u32 1
    v176 = add v173, u32 1
    store v174 at v86
    store v176 at v90
    jmp b30()
  b10():
    v94 = load v86
    inc_rc v94
    v95 = load v89
    inc_rc v95
    v96 = load v91
    v97 = not v96
    constrain v96 == u1 0
    inc_rc v94
    inc_rc v95
    jmp b11(u32 0)
  b11(v9: u32):
    v99 = lt v9, u32 3
    jmpif v99 then: b22, else: b12
  b22():
    v154 = load v90
    v155 = lt v9, v154
    jmpif v155 then: b23, else: b24
  b23():
    v156 = load v86
    v157 = load v89
    v158 = array_get v157, index v9
    v159 = array_get v156, index v9
    v160 = add v158, v159
    v161 = array_set v157, index v9, value v160
    v162 = add v9, u32 1
    store v161 at v89
    jmp b24()
  b24():
    v163 = add v9, u32 1
    jmp b11(v163)
  b12():
    v100 = load v86
    v101 = load v89
    v104 = call poseidon2_permutation(v101, u32 4)
    inc_rc v104
    dec_rc v100
    dec_rc v104
    store v104 at v89
    store u1 1 at v91
    v106 = array_get v104, index u32 0
    dec_rc v100
    dec_rc v104
    v107 = truncate v106 to 32 bits, max_bit_size: 254
    v108 = cast v107 as u32
    v109 = load v0
    jmp b13(u32 0)
  b13(v10: u32):
    v110 = lt v10, v109
    jmpif v110 then: b14, else: b21
  b14():
    v111 = load v0
    v112 = load v1
    v113 = mul v10, v10
    v114 = add v10, v113
    v115 = div v114, u32 2
    v116 = add v108, v115
    v117 = mod v116, v111
    v118 = mul v117, u32 4
    v119 = lt v117, v111
    constrain v119 == u1 1 '"Index out of bounds"'
    v120 = array_get v112, index v118
    v121 = add v118, u32 1
    v122 = lt v117, v111
    constrain v122 == u1 1 '"Index out of bounds"'
    v123 = array_get v112, index v121
    v124 = add v118, u32 2
    v125 = lt v117, v111
    constrain v125 == u1 1 '"Index out of bounds"'
    v126 = array_get v112, index v124
    v127 = add v118, u32 3
    v128 = lt v117, v111
    constrain v128 == u1 1 '"Index out of bounds"'
    v129 = array_get v112, index v127
    v130 = allocate
    v131 = allocate
    v132 = allocate
    v133 = allocate
    v134 = allocate
    store u1 0 at v134
    v135 = not v120
    v136 = or v129, v135
    jmpif v136 then: b17, else: b15
  b17():
    store u1 1 at v134
    v138 = load v2
    v139 = add v138, u32 1
    store v139 at v2
    jmp b18()
  b18():
    v140 = load v134
    jmpif v140 then: b20, else: b19
  b20():
    store u1 1 at v130
    store v3 at v131
    store v4 at v132
    store u1 0 at v133
    v142 = load v1
    v143 = load v2
    v144 = mul v117, u32 4
    v145 = array_set v142, index v144, value u1 1
    v146 = add v144, u32 1
    v147 = array_set v145, index v146, value v3
    v148 = add v146, u32 1
    v149 = array_set v147, index v148, value v4
    v150 = add v148, u32 1
    v151 = array_set v149, index v150, value u1 0
    v152 = add v150, u32 1
    store v151 at v1
    store v143 at v2
    jmp b21()
  b21():
    v153 = load v1
    dec_rc v153
    return 
  b19():
    v141 = add v10, u32 1
    jmp b13(v141)
  b15():
    v137 = eq v123, v3
    jmpif v137 then: b16, else: b18
  b16():
    store u1 1 at v134
    jmp b18()
}

After Inlining:
brillig fn main f0 {
  b0(v0: [Field, Field; 6]):
    v2 = array_get v0, index u32 0
    v4 = array_get v0, index u32 1
    v5 = array_get v0, index u32 0
    v6 = array_get v0, index u32 1
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    v10 = allocate
    store u32 1 at v10
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    v11 = allocate
    store [u1 0, Field 0, Field 0, u1 0] at v11
    v12 = allocate
    store u32 0 at v12
    call f1(v10, v11, v12, v2, v6)
    constrain u32 0 == u32 1 '"UHashMap after one insert should have a length of 1 element."'
    return 
}
brillig fn insert f1 {
  b0(v0: &mut u32, v1: &mut [u1, Field, Field, u1], v2: &mut u32, v3: Field, v4: Field):
    v12 = load v1
    inc_rc v12
    inc_rc v12
    v13 = load v0
    v14 = load v2
    v16 = add v14, u32 1
    v18 = div v13, u32 2
    v19 = lt v16, v18
    v20 = not v19
    jmpif v20 then: b1, else: b8
  b1():
    v21 = load v0
    v22 = mul v21, u32 2
    v23 = allocate
    store u32 0 at v23
    inc_rc []
    v26 = allocate
    store [] at v26
    jmp b2(u32 0)
  b2(v5: u32):
    v27 = lt v5, v22
    jmpif v27 then: b38, else: b3
  b38():
    v225 = load v23
    v226 = load v26
    v227, v228 = call slice_push_back(v225, v226, u1 0, Field 0, Field 0, u1 0)
    inc_rc v228
    store v227 at v23
    store v228 at v26
    v229 = add v5, u32 1
    jmp b2(v229)
  b3():
    v28 = load v23
    v29 = load v26
    inc_rc v29
    v30 = allocate
    store v28 at v30
    inc_rc v29
    v31 = allocate
    store v29 at v31
    v32 = allocate
    store u32 0 at v32
    v33 = load v0
    v34 = load v1
    v35 = load v2
    v36 = allocate
    store u32 0 at v36
    inc_rc []
    v38 = allocate
    store [] at v38
    inc_rc v34
    jmp b4(u32 0)
  b4(v6: u32):
    v39 = lt v6, v33
    jmpif v39 then: b35, else: b5
  b35():
    v205 = mul v6, u32 4
    v206 = lt v6, v33
    constrain v206 == u1 1 '"Index out of bounds"'
    v207 = array_get v34, index v205
    v208 = add v205, u32 1
    v209 = lt v6, v33
    constrain v209 == u1 1 '"Index out of bounds"'
    v210 = array_get v34, index v208
    v211 = add v205, u32 2
    v212 = lt v6, v33
    constrain v212 == u1 1 '"Index out of bounds"'
    v213 = array_get v34, index v211
    v214 = add v205, u32 3
    v215 = lt v6, v33
    constrain v215 == u1 1 '"Index out of bounds"'
    v216 = array_get v34, index v214
    v217 = not v216
    v218 = mul v217, v207
    jmpif v218 then: b36, else: b37
  b36():
    v219 = load v36
    v220 = load v38
    v222, v223 = call slice_push_back(v219, v220, v210, v213)
    inc_rc v223
    store v222 at v36
    store v223 at v38
    jmp b37()
  b37():
    v224 = add v6, u32 1
    jmp b4(v224)
  b5():
    inc_rc [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46]
    v67 = load v36
    v68 = load v38
    v69 = eq v67, v35
    constrain v67 == v35, data [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46], u32 0
    inc_rc v68
    jmp b6(u32 0)
  b6(v7: u32):
    v70 = lt v7, v67
    jmpif v70 then: b34, else: b7
  b34():
    v197 = mul v7, u32 2
    v198 = lt v7, v67
    constrain v198 == u1 1 '"Index out of bounds"'
    v199 = array_get v68, index v197
    v200 = add v197, u32 1
    v201 = lt v7, v67
    constrain v201 == u1 1 '"Index out of bounds"'
    v202 = array_get v68, index v200
    call f1(v30, v31, v32, v199, v202)
    v204 = add v7, u32 1
    jmp b6(v204)
  b7():
    v71 = load v30
    v72 = load v31
    v73 = load v32
    inc_rc v72
    store v71 at v0
    store v72 at v1
    store v73 at v2
    jmp b8()
  b8():
    v74 = load v1
    dec_rc v74
    inc_rc []
    v76 = allocate
    inc_rc []
    v77 = allocate
    inc_rc []
    inc_rc []
    inc_rc [v3]
    dec_rc [v3]
    dec_rc [v3]
    inc_rc [Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0]
    v82 = allocate
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    v83 = allocate
    v84 = allocate
    v85 = allocate
    inc_rc [Field 0, Field 0, Field 0]
    v86 = allocate
    store [Field 0, Field 0, Field 0] at v86
    inc_rc [Field 0, Field 0, Field 0, Field 2⁶⁴]
    v89 = allocate
    store [Field 0, Field 0, Field 0, Field 2⁶⁴] at v89
    v90 = allocate
    store u32 0 at v90
    v91 = allocate
    store u1 0 at v91
    jmp b9(u32 0)
  b9(v8: u32):
    v93 = eq v8, u32 0
    jmpif v93 then: b25, else: b10
  b25():
    v164 = eq v8, u32 0
    constrain v8 == u32 0 '"Index out of bounds"'
    v165 = array_get [v3], index v8
    v166 = load v86
    inc_rc v166
    v167 = load v89
    inc_rc v167
    v168 = load v90
    v169 = load v91
    v170 = not v169
    constrain v169 == u1 0
    v171 = eq v168, u32 3
    jmpif v171 then: b27, else: b26
  b27():
    v177 = load v86
    inc_rc v177
    v178 = load v89
    inc_rc v178
    jmp b28(u32 0)
  b28(v11: u32):
    v179 = lt v11, u32 3
    jmpif v179 then: b31, else: b29
  b31():
    v187 = load v90
    v188 = lt v11, v187
    jmpif v188 then: b32, else: b33
  b32():
    v189 = load v86
    v190 = load v89
    v191 = array_get v190, index v11
    v192 = array_get v189, index v11
    v193 = add v191, v192
    v194 = array_set v190, index v11, value v193
    v195 = add v11, u32 1
    store v194 at v89
    jmp b33()
  b33():
    v196 = add v11, u32 1
    jmp b28(v196)
  b29():
    v180 = load v86
    v181 = load v89
    v182 = call poseidon2_permutation(v181, u32 4)
    inc_rc v182
    dec_rc v180
    dec_rc v182
    v183 = array_set v180, index u32 0, value v165
    store v183 at v86
    store v182 at v89
    store u32 1 at v90
    jmp b30()
  b30():
    v184 = load v86
    dec_rc v184
    v185 = load v89
    dec_rc v185
    v186 = add v8, u32 1
    jmp b9(v186)
  b26():
    v172 = load v86
    v173 = load v90
    v174 = array_set v172, index v173, value v165
    v175 = add v173, u32 1
    v176 = add v173, u32 1
    store v174 at v86
    store v176 at v90
    jmp b30()
  b10():
    v94 = load v86
    inc_rc v94
    v95 = load v89
    inc_rc v95
    v96 = load v91
    v97 = not v96
    constrain v96 == u1 0
    inc_rc v94
    inc_rc v95
    jmp b11(u32 0)
  b11(v9: u32):
    v99 = lt v9, u32 3
    jmpif v99 then: b22, else: b12
  b22():
    v154 = load v90
    v155 = lt v9, v154
    jmpif v155 then: b23, else: b24
  b23():
    v156 = load v86
    v157 = load v89
    v158 = array_get v157, index v9
    v159 = array_get v156, index v9
    v160 = add v158, v159
    v161 = array_set v157, index v9, value v160
    v162 = add v9, u32 1
    store v161 at v89
    jmp b24()
  b24():
    v163 = add v9, u32 1
    jmp b11(v163)
  b12():
    v100 = load v86
    v101 = load v89
    v104 = call poseidon2_permutation(v101, u32 4)
    inc_rc v104
    dec_rc v100
    dec_rc v104
    store v104 at v89
    store u1 1 at v91
    v106 = array_get v104, index u32 0
    dec_rc v100
    dec_rc v104
    v107 = truncate v106 to 32 bits, max_bit_size: 254
    v108 = cast v107 as u32
    v109 = load v0
    jmp b13(u32 0)
  b13(v10: u32):
    v110 = lt v10, v109
    jmpif v110 then: b14, else: b21
  b14():
    v111 = load v0
    v112 = load v1
    v113 = mul v10, v10
    v114 = add v10, v113
    v115 = div v114, u32 2
    v116 = add v108, v115
    v117 = mod v116, v111
    v118 = mul v117, u32 4
    v119 = lt v117, v111
    constrain v119 == u1 1 '"Index out of bounds"'
    v120 = array_get v112, index v118
    v121 = add v118, u32 1
    v122 = lt v117, v111
    constrain v122 == u1 1 '"Index out of bounds"'
    v123 = array_get v112, index v121
    v124 = add v118, u32 2
    v125 = lt v117, v111
    constrain v125 == u1 1 '"Index out of bounds"'
    v126 = array_get v112, index v124
    v127 = add v118, u32 3
    v128 = lt v117, v111
    constrain v128 == u1 1 '"Index out of bounds"'
    v129 = array_get v112, index v127
    v130 = allocate
    v131 = allocate
    v132 = allocate
    v133 = allocate
    v134 = allocate
    store u1 0 at v134
    v135 = not v120
    v136 = or v129, v135
    jmpif v136 then: b17, else: b15
  b17():
    store u1 1 at v134
    v138 = load v2
    v139 = add v138, u32 1
    store v139 at v2
    jmp b18()
  b18():
    v140 = load v134
    jmpif v140 then: b20, else: b19
  b20():
    store u1 1 at v130
    store v3 at v131
    store v4 at v132
    store u1 0 at v133
    v142 = load v1
    v143 = load v2
    v144 = mul v117, u32 4
    v145 = array_set v142, index v144, value u1 1
    v146 = add v144, u32 1
    v147 = array_set v145, index v146, value v3
    v148 = add v146, u32 1
    v149 = array_set v147, index v148, value v4
    v150 = add v148, u32 1
    v151 = array_set v149, index v150, value u1 0
    v152 = add v150, u32 1
    store v151 at v1
    store v143 at v2
    jmp b21()
  b21():
    v153 = load v1
    dec_rc v153
    return 
  b19():
    v141 = add v10, u32 1
    jmp b13(v141)
  b15():
    v137 = eq v123, v3
    jmpif v137 then: b16, else: b18
  b16():
    store u1 1 at v134
    jmp b18()
}

After Remove IfElse:
brillig fn main f0 {
  b0(v0: [Field, Field; 6]):
    v2 = array_get v0, index u32 0
    v4 = array_get v0, index u32 1
    v5 = array_get v0, index u32 0
    v6 = array_get v0, index u32 1
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    v10 = allocate
    store u32 1 at v10
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    v11 = allocate
    store [u1 0, Field 0, Field 0, u1 0] at v11
    v12 = allocate
    store u32 0 at v12
    call f1(v10, v11, v12, v2, v6)
    constrain u32 0 == u32 1 '"UHashMap after one insert should have a length of 1 element."'
    return 
}
brillig fn insert f1 {
  b0(v0: &mut u32, v1: &mut [u1, Field, Field, u1], v2: &mut u32, v3: Field, v4: Field):
    v12 = load v1
    inc_rc v12
    inc_rc v12
    v13 = load v0
    v14 = load v2
    v16 = add v14, u32 1
    v18 = div v13, u32 2
    v19 = lt v16, v18
    v20 = not v19
    jmpif v20 then: b1, else: b8
  b1():
    v21 = load v0
    v22 = mul v21, u32 2
    v23 = allocate
    store u32 0 at v23
    inc_rc []
    v26 = allocate
    store [] at v26
    jmp b2(u32 0)
  b2(v5: u32):
    v27 = lt v5, v22
    jmpif v27 then: b38, else: b3
  b38():
    v225 = load v23
    v226 = load v26
    v227, v228 = call slice_push_back(v225, v226, u1 0, Field 0, Field 0, u1 0)
    inc_rc v228
    store v227 at v23
    store v228 at v26
    v229 = add v5, u32 1
    jmp b2(v229)
  b3():
    v28 = load v23
    v29 = load v26
    inc_rc v29
    v30 = allocate
    store v28 at v30
    inc_rc v29
    v31 = allocate
    store v29 at v31
    v32 = allocate
    store u32 0 at v32
    v33 = load v0
    v34 = load v1
    v35 = load v2
    v36 = allocate
    store u32 0 at v36
    inc_rc []
    v38 = allocate
    store [] at v38
    inc_rc v34
    jmp b4(u32 0)
  b4(v6: u32):
    v39 = lt v6, v33
    jmpif v39 then: b35, else: b5
  b35():
    v205 = mul v6, u32 4
    v206 = lt v6, v33
    constrain v206 == u1 1 '"Index out of bounds"'
    v207 = array_get v34, index v205
    v208 = add v205, u32 1
    v209 = lt v6, v33
    constrain v209 == u1 1 '"Index out of bounds"'
    v210 = array_get v34, index v208
    v211 = add v205, u32 2
    v212 = lt v6, v33
    constrain v212 == u1 1 '"Index out of bounds"'
    v213 = array_get v34, index v211
    v214 = add v205, u32 3
    v215 = lt v6, v33
    constrain v215 == u1 1 '"Index out of bounds"'
    v216 = array_get v34, index v214
    v217 = not v216
    v218 = mul v217, v207
    jmpif v218 then: b36, else: b37
  b36():
    v219 = load v36
    v220 = load v38
    v222, v223 = call slice_push_back(v219, v220, v210, v213)
    inc_rc v223
    store v222 at v36
    store v223 at v38
    jmp b37()
  b37():
    v224 = add v6, u32 1
    jmp b4(v224)
  b5():
    inc_rc [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46]
    v67 = load v36
    v68 = load v38
    v69 = eq v67, v35
    constrain v67 == v35, data [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46], u32 0
    inc_rc v68
    jmp b6(u32 0)
  b6(v7: u32):
    v70 = lt v7, v67
    jmpif v70 then: b34, else: b7
  b34():
    v197 = mul v7, u32 2
    v198 = lt v7, v67
    constrain v198 == u1 1 '"Index out of bounds"'
    v199 = array_get v68, index v197
    v200 = add v197, u32 1
    v201 = lt v7, v67
    constrain v201 == u1 1 '"Index out of bounds"'
    v202 = array_get v68, index v200
    call f1(v30, v31, v32, v199, v202)
    v204 = add v7, u32 1
    jmp b6(v204)
  b7():
    v71 = load v30
    v72 = load v31
    v73 = load v32
    inc_rc v72
    store v71 at v0
    store v72 at v1
    store v73 at v2
    jmp b8()
  b8():
    v74 = load v1
    dec_rc v74
    inc_rc []
    v76 = allocate
    inc_rc []
    v77 = allocate
    inc_rc []
    inc_rc []
    inc_rc [v3]
    dec_rc [v3]
    dec_rc [v3]
    inc_rc [Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0]
    v82 = allocate
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    v83 = allocate
    v84 = allocate
    v85 = allocate
    inc_rc [Field 0, Field 0, Field 0]
    v86 = allocate
    store [Field 0, Field 0, Field 0] at v86
    inc_rc [Field 0, Field 0, Field 0, Field 2⁶⁴]
    v89 = allocate
    store [Field 0, Field 0, Field 0, Field 2⁶⁴] at v89
    v90 = allocate
    store u32 0 at v90
    v91 = allocate
    store u1 0 at v91
    jmp b9(u32 0)
  b9(v8: u32):
    v93 = eq v8, u32 0
    jmpif v93 then: b25, else: b10
  b25():
    v164 = eq v8, u32 0
    constrain v8 == u32 0 '"Index out of bounds"'
    v165 = array_get [v3], index v8
    v166 = load v86
    inc_rc v166
    v167 = load v89
    inc_rc v167
    v168 = load v90
    v169 = load v91
    v170 = not v169
    constrain v169 == u1 0
    v171 = eq v168, u32 3
    jmpif v171 then: b27, else: b26
  b27():
    v177 = load v86
    inc_rc v177
    v178 = load v89
    inc_rc v178
    jmp b28(u32 0)
  b28(v11: u32):
    v179 = lt v11, u32 3
    jmpif v179 then: b31, else: b29
  b31():
    v187 = load v90
    v188 = lt v11, v187
    jmpif v188 then: b32, else: b33
  b32():
    v189 = load v86
    v190 = load v89
    v191 = array_get v190, index v11
    v192 = array_get v189, index v11
    v193 = add v191, v192
    v194 = array_set v190, index v11, value v193
    v195 = add v11, u32 1
    store v194 at v89
    jmp b33()
  b33():
    v196 = add v11, u32 1
    jmp b28(v196)
  b29():
    v180 = load v86
    v181 = load v89
    v182 = call poseidon2_permutation(v181, u32 4)
    inc_rc v182
    dec_rc v180
    dec_rc v182
    v183 = array_set v180, index u32 0, value v165
    store v183 at v86
    store v182 at v89
    store u32 1 at v90
    jmp b30()
  b30():
    v184 = load v86
    dec_rc v184
    v185 = load v89
    dec_rc v185
    v186 = add v8, u32 1
    jmp b9(v186)
  b26():
    v172 = load v86
    v173 = load v90
    v174 = array_set v172, index v173, value v165
    v175 = add v173, u32 1
    v176 = add v173, u32 1
    store v174 at v86
    store v176 at v90
    jmp b30()
  b10():
    v94 = load v86
    inc_rc v94
    v95 = load v89
    inc_rc v95
    v96 = load v91
    v97 = not v96
    constrain v96 == u1 0
    inc_rc v94
    inc_rc v95
    jmp b11(u32 0)
  b11(v9: u32):
    v99 = lt v9, u32 3
    jmpif v99 then: b22, else: b12
  b22():
    v154 = load v90
    v155 = lt v9, v154
    jmpif v155 then: b23, else: b24
  b23():
    v156 = load v86
    v157 = load v89
    v158 = array_get v157, index v9
    v159 = array_get v156, index v9
    v160 = add v158, v159
    v161 = array_set v157, index v9, value v160
    v162 = add v9, u32 1
    store v161 at v89
    jmp b24()
  b24():
    v163 = add v9, u32 1
    jmp b11(v163)
  b12():
    v100 = load v86
    v101 = load v89
    v104 = call poseidon2_permutation(v101, u32 4)
    inc_rc v104
    dec_rc v100
    dec_rc v104
    store v104 at v89
    store u1 1 at v91
    v106 = array_get v104, index u32 0
    dec_rc v100
    dec_rc v104
    v107 = truncate v106 to 32 bits, max_bit_size: 254
    v108 = cast v107 as u32
    v109 = load v0
    jmp b13(u32 0)
  b13(v10: u32):
    v110 = lt v10, v109
    jmpif v110 then: b14, else: b21
  b14():
    v111 = load v0
    v112 = load v1
    v113 = mul v10, v10
    v114 = add v10, v113
    v115 = div v114, u32 2
    v116 = add v108, v115
    v117 = mod v116, v111
    v118 = mul v117, u32 4
    v119 = lt v117, v111
    constrain v119 == u1 1 '"Index out of bounds"'
    v120 = array_get v112, index v118
    v121 = add v118, u32 1
    v122 = lt v117, v111
    constrain v122 == u1 1 '"Index out of bounds"'
    v123 = array_get v112, index v121
    v124 = add v118, u32 2
    v125 = lt v117, v111
    constrain v125 == u1 1 '"Index out of bounds"'
    v126 = array_get v112, index v124
    v127 = add v118, u32 3
    v128 = lt v117, v111
    constrain v128 == u1 1 '"Index out of bounds"'
    v129 = array_get v112, index v127
    v130 = allocate
    v131 = allocate
    v132 = allocate
    v133 = allocate
    v134 = allocate
    store u1 0 at v134
    v135 = not v120
    v136 = or v129, v135
    jmpif v136 then: b17, else: b15
  b17():
    store u1 1 at v134
    v138 = load v2
    v139 = add v138, u32 1
    store v139 at v2
    jmp b18()
  b18():
    v140 = load v134
    jmpif v140 then: b20, else: b19
  b20():
    store u1 1 at v130
    store v3 at v131
    store v4 at v132
    store u1 0 at v133
    v142 = load v1
    v143 = load v2
    v144 = mul v117, u32 4
    v145 = array_set v142, index v144, value u1 1
    v146 = add v144, u32 1
    v147 = array_set v145, index v146, value v3
    v148 = add v146, u32 1
    v149 = array_set v147, index v148, value v4
    v150 = add v148, u32 1
    v151 = array_set v149, index v150, value u1 0
    v152 = add v150, u32 1
    store v151 at v1
    store v143 at v2
    jmp b21()
  b21():
    v153 = load v1
    dec_rc v153
    return 
  b19():
    v141 = add v10, u32 1
    jmp b13(v141)
  b15():
    v137 = eq v123, v3
    jmpif v137 then: b16, else: b18
  b16():
    store u1 1 at v134
    jmp b18()
}

After Constant Folding:
brillig fn main f0 {
  b0(v0: [Field, Field; 6]):
    v2 = array_get v0, index u32 0
    v4 = array_get v0, index u32 1
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    v8 = allocate
    store u32 1 at v8
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    v9 = allocate
    store [u1 0, Field 0, Field 0, u1 0] at v9
    v10 = allocate
    store u32 0 at v10
    call f1(v8, v9, v10, v2, v4)
    constrain u32 0 == u32 1 '"UHashMap after one insert should have a length of 1 element."'
    return 
}
brillig fn insert f1 {
  b0(v0: &mut u32, v1: &mut [u1, Field, Field, u1], v2: &mut u32, v3: Field, v4: Field):
    v12 = load v1
    inc_rc v12
    inc_rc v12
    v13 = load v0
    v14 = load v2
    v16 = add v14, u32 1
    v18 = div v13, u32 2
    v19 = lt v16, v18
    v20 = not v19
    jmpif v20 then: b1, else: b8
  b1():
    v21 = load v0
    v22 = mul v21, u32 2
    v23 = allocate
    store u32 0 at v23
    inc_rc []
    v26 = allocate
    store [] at v26
    jmp b2(u32 0)
  b2(v5: u32):
    v27 = lt v5, v22
    jmpif v27 then: b38, else: b3
  b38():
    v217 = load v23
    v218 = load v26
    v219, v220 = call slice_push_back(v217, v218, u1 0, Field 0, Field 0, u1 0)
    inc_rc v220
    store v219 at v23
    store v220 at v26
    v221 = add v5, u32 1
    jmp b2(v221)
  b3():
    v28 = load v23
    v29 = load v26
    inc_rc v29
    v30 = allocate
    store v28 at v30
    inc_rc v29
    v31 = allocate
    store v29 at v31
    v32 = allocate
    store u32 0 at v32
    v33 = load v0
    v34 = load v1
    v35 = load v2
    v36 = allocate
    store u32 0 at v36
    inc_rc []
    v38 = allocate
    store [] at v38
    inc_rc v34
    jmp b4(u32 0)
  b4(v6: u32):
    v39 = lt v6, v33
    jmpif v39 then: b35, else: b5
  b35():
    v200 = mul v6, u32 4
    v201 = lt v6, v33
    constrain v201 == u1 1 '"Index out of bounds"'
    v202 = array_get v34, index v200
    v203 = add v200, u32 1
    constrain v201 == u1 1 '"Index out of bounds"'
    v204 = array_get v34, index v203
    v205 = add v200, u32 2
    constrain v201 == u1 1 '"Index out of bounds"'
    v206 = array_get v34, index v205
    v207 = add v200, u32 3
    constrain v201 == u1 1 '"Index out of bounds"'
    v208 = array_get v34, index v207
    v209 = not v208
    v210 = mul v209, v202
    jmpif v210 then: b36, else: b37
  b36():
    v211 = load v36
    v212 = load v38
    v214, v215 = call slice_push_back(v211, v212, v204, v206)
    inc_rc v215
    store v214 at v36
    store v215 at v38
    jmp b37()
  b37():
    v216 = add v6, u32 1
    jmp b4(v216)
  b5():
    inc_rc [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46]
    v67 = load v36
    v68 = load v38
    v69 = eq v67, v35
    constrain v67 == v35, data [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46], u32 0
    inc_rc v68
    jmp b6(u32 0)
  b6(v7: u32):
    v70 = lt v7, v67
    jmpif v70 then: b34, else: b7
  b34():
    v193 = mul v7, u32 2
    v194 = lt v7, v67
    constrain v194 == u1 1 '"Index out of bounds"'
    v195 = array_get v68, index v193
    v196 = add v193, u32 1
    constrain v194 == u1 1 '"Index out of bounds"'
    v197 = array_get v68, index v196
    call f1(v30, v31, v32, v195, v197)
    v199 = add v7, u32 1
    jmp b6(v199)
  b7():
    v71 = load v30
    v72 = load v31
    v73 = load v32
    inc_rc v72
    store v71 at v0
    store v72 at v1
    store v73 at v2
    jmp b8()
  b8():
    v74 = load v1
    dec_rc v74
    inc_rc []
    v76 = allocate
    inc_rc []
    v77 = allocate
    inc_rc []
    inc_rc []
    inc_rc [v3]
    dec_rc [v3]
    dec_rc [v3]
    inc_rc [Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0]
    v82 = allocate
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    v83 = allocate
    v84 = allocate
    v85 = allocate
    inc_rc [Field 0, Field 0, Field 0]
    v86 = allocate
    store [Field 0, Field 0, Field 0] at v86
    inc_rc [Field 0, Field 0, Field 0, Field 2⁶⁴]
    v89 = allocate
    store [Field 0, Field 0, Field 0, Field 2⁶⁴] at v89
    v90 = allocate
    store u32 0 at v90
    v91 = allocate
    store u1 0 at v91
    jmp b9(u32 0)
  b9(v8: u32):
    v93 = eq v8, u32 0
    jmpif v93 then: b25, else: b10
  b25():
    v161 = eq v8, u32 0
    constrain v8 == u32 0 '"Index out of bounds"'
    v162 = array_get [v3], index v8
    v163 = load v86
    inc_rc v163
    v164 = load v89
    inc_rc v164
    v165 = load v90
    v166 = load v91
    v167 = not v166
    constrain v166 == u1 0
    v168 = eq v165, u32 3
    jmpif v168 then: b27, else: b26
  b27():
    v173 = load v86
    inc_rc v173
    v174 = load v89
    inc_rc v174
    jmp b28(u32 0)
  b28(v11: u32):
    v175 = lt v11, u32 3
    jmpif v175 then: b31, else: b29
  b31():
    v183 = load v90
    v184 = lt v11, v183
    jmpif v184 then: b32, else: b33
  b32():
    v185 = load v86
    v186 = load v89
    v187 = array_get v186, index v11
    v188 = array_get v185, index v11
    v189 = add v187, v188
    v190 = array_set v186, index v11, value v189
    v191 = add v11, u32 1
    store v190 at v89
    jmp b33()
  b33():
    v192 = add v11, u32 1
    jmp b28(v192)
  b29():
    v176 = load v86
    v177 = load v89
    v178 = call poseidon2_permutation(v177, u32 4)
    inc_rc v178
    dec_rc v176
    dec_rc v178
    v179 = array_set v176, index u32 0, value v162
    store v179 at v86
    store v178 at v89
    store u32 1 at v90
    jmp b30()
  b30():
    v180 = load v86
    dec_rc v180
    v181 = load v89
    dec_rc v181
    v182 = add v8, u32 1
    jmp b9(v182)
  b26():
    v169 = load v86
    v170 = load v90
    v171 = array_set v169, index v170, value v162
    v172 = add v170, u32 1
    store v171 at v86
    store v172 at v90
    jmp b30()
  b10():
    v94 = load v86
    inc_rc v94
    v95 = load v89
    inc_rc v95
    v96 = load v91
    v97 = not v96
    constrain v96 == u1 0
    inc_rc v94
    inc_rc v95
    jmp b11(u32 0)
  b11(v9: u32):
    v99 = lt v9, u32 3
    jmpif v99 then: b22, else: b12
  b22():
    v151 = load v90
    v152 = lt v9, v151
    jmpif v152 then: b23, else: b24
  b23():
    v153 = load v86
    v154 = load v89
    v155 = array_get v154, index v9
    v156 = array_get v153, index v9
    v157 = add v155, v156
    v158 = array_set v154, index v9, value v157
    v159 = add v9, u32 1
    store v158 at v89
    jmp b24()
  b24():
    v160 = add v9, u32 1
    jmp b11(v160)
  b12():
    v100 = load v86
    v101 = load v89
    v104 = call poseidon2_permutation(v101, u32 4)
    inc_rc v104
    dec_rc v100
    dec_rc v104
    store v104 at v89
    store u1 1 at v91
    v106 = array_get v104, index u32 0
    dec_rc v100
    dec_rc v104
    v107 = truncate v106 to 32 bits, max_bit_size: 254
    v108 = cast v107 as u32
    v109 = load v0
    jmp b13(u32 0)
  b13(v10: u32):
    v110 = lt v10, v109
    jmpif v110 then: b14, else: b21
  b14():
    v111 = load v0
    v112 = load v1
    v113 = mul v10, v10
    v114 = add v10, v113
    v115 = div v114, u32 2
    v116 = add v108, v115
    v117 = mod v116, v111
    v118 = mul v117, u32 4
    v119 = lt v117, v111
    constrain v119 == u1 1 '"Index out of bounds"'
    v120 = array_get v112, index v118
    v121 = add v118, u32 1
    constrain v119 == u1 1 '"Index out of bounds"'
    v122 = array_get v112, index v121
    v123 = add v118, u32 2
    constrain v119 == u1 1 '"Index out of bounds"'
    v124 = array_get v112, index v123
    v125 = add v118, u32 3
    constrain v119 == u1 1 '"Index out of bounds"'
    v126 = array_get v112, index v125
    v127 = allocate
    v128 = allocate
    v129 = allocate
    v130 = allocate
    v131 = allocate
    store u1 0 at v131
    v132 = not v120
    v133 = or v126, v132
    jmpif v133 then: b17, else: b15
  b17():
    store u1 1 at v131
    v135 = load v2
    v136 = add v135, u32 1
    store v136 at v2
    jmp b18()
  b18():
    v137 = load v131
    jmpif v137 then: b20, else: b19
  b20():
    store u1 1 at v127
    store v3 at v128
    store v4 at v129
    store u1 0 at v130
    v139 = load v1
    v140 = load v2
    v141 = mul v117, u32 4
    v142 = array_set v139, index v141, value u1 1
    v143 = add v141, u32 1
    v144 = array_set v142, index v143, value v3
    v145 = add v143, u32 1
    v146 = array_set v144, index v145, value v4
    v147 = add v145, u32 1
    v148 = array_set v146, index v147, value u1 0
    v149 = add v147, u32 1
    store v148 at v1
    store v140 at v2
    jmp b21()
  b21():
    v150 = load v1
    dec_rc v150
    return 
  b19():
    v138 = add v10, u32 1
    jmp b13(v138)
  b15():
    v134 = eq v122, v3
    jmpif v134 then: b16, else: b18
  b16():
    store u1 1 at v131
    jmp b18()
}

After EnableSideEffectsIf removal:
brillig fn main f0 {
  b0(v0: [Field, Field; 6]):
    v2 = array_get v0, index u32 0
    v4 = array_get v0, index u32 1
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    v8 = allocate
    store u32 1 at v8
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    v9 = allocate
    store [u1 0, Field 0, Field 0, u1 0] at v9
    v10 = allocate
    store u32 0 at v10
    call f1(v8, v9, v10, v2, v4)
    constrain u32 0 == u32 1 '"UHashMap after one insert should have a length of 1 element."'
    return 
}
brillig fn insert f1 {
  b0(v0: &mut u32, v1: &mut [u1, Field, Field, u1], v2: &mut u32, v3: Field, v4: Field):
    v12 = load v1
    inc_rc v12
    inc_rc v12
    v13 = load v0
    v14 = load v2
    v16 = add v14, u32 1
    v18 = div v13, u32 2
    v19 = lt v16, v18
    v20 = not v19
    jmpif v20 then: b1, else: b8
  b1():
    v21 = load v0
    v22 = mul v21, u32 2
    v23 = allocate
    store u32 0 at v23
    inc_rc []
    v26 = allocate
    store [] at v26
    jmp b2(u32 0)
  b2(v5: u32):
    v27 = lt v5, v22
    jmpif v27 then: b38, else: b3
  b38():
    v217 = load v23
    v218 = load v26
    v219, v220 = call slice_push_back(v217, v218, u1 0, Field 0, Field 0, u1 0)
    inc_rc v220
    store v219 at v23
    store v220 at v26
    v221 = add v5, u32 1
    jmp b2(v221)
  b3():
    v28 = load v23
    v29 = load v26
    inc_rc v29
    v30 = allocate
    store v28 at v30
    inc_rc v29
    v31 = allocate
    store v29 at v31
    v32 = allocate
    store u32 0 at v32
    v33 = load v0
    v34 = load v1
    v35 = load v2
    v36 = allocate
    store u32 0 at v36
    inc_rc []
    v38 = allocate
    store [] at v38
    inc_rc v34
    jmp b4(u32 0)
  b4(v6: u32):
    v39 = lt v6, v33
    jmpif v39 then: b35, else: b5
  b35():
    v200 = mul v6, u32 4
    v201 = lt v6, v33
    constrain v201 == u1 1 '"Index out of bounds"'
    v202 = array_get v34, index v200
    v203 = add v200, u32 1
    constrain v201 == u1 1 '"Index out of bounds"'
    v204 = array_get v34, index v203
    v205 = add v200, u32 2
    constrain v201 == u1 1 '"Index out of bounds"'
    v206 = array_get v34, index v205
    v207 = add v200, u32 3
    constrain v201 == u1 1 '"Index out of bounds"'
    v208 = array_get v34, index v207
    v209 = not v208
    v210 = mul v209, v202
    jmpif v210 then: b36, else: b37
  b36():
    v211 = load v36
    v212 = load v38
    v214, v215 = call slice_push_back(v211, v212, v204, v206)
    inc_rc v215
    store v214 at v36
    store v215 at v38
    jmp b37()
  b37():
    v216 = add v6, u32 1
    jmp b4(v216)
  b5():
    inc_rc [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46]
    v67 = load v36
    v68 = load v38
    v69 = eq v67, v35
    constrain v67 == v35, data [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46], u32 0
    inc_rc v68
    jmp b6(u32 0)
  b6(v7: u32):
    v70 = lt v7, v67
    jmpif v70 then: b34, else: b7
  b34():
    v193 = mul v7, u32 2
    v194 = lt v7, v67
    constrain v194 == u1 1 '"Index out of bounds"'
    v195 = array_get v68, index v193
    v196 = add v193, u32 1
    constrain v194 == u1 1 '"Index out of bounds"'
    v197 = array_get v68, index v196
    call f1(v30, v31, v32, v195, v197)
    v199 = add v7, u32 1
    jmp b6(v199)
  b7():
    v71 = load v30
    v72 = load v31
    v73 = load v32
    inc_rc v72
    store v71 at v0
    store v72 at v1
    store v73 at v2
    jmp b8()
  b8():
    v74 = load v1
    dec_rc v74
    inc_rc []
    v76 = allocate
    inc_rc []
    v77 = allocate
    inc_rc []
    inc_rc []
    inc_rc [v3]
    dec_rc [v3]
    dec_rc [v3]
    inc_rc [Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0]
    v82 = allocate
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    v83 = allocate
    v84 = allocate
    v85 = allocate
    inc_rc [Field 0, Field 0, Field 0]
    v86 = allocate
    store [Field 0, Field 0, Field 0] at v86
    inc_rc [Field 0, Field 0, Field 0, Field 2⁶⁴]
    v89 = allocate
    store [Field 0, Field 0, Field 0, Field 2⁶⁴] at v89
    v90 = allocate
    store u32 0 at v90
    v91 = allocate
    store u1 0 at v91
    jmp b9(u32 0)
  b9(v8: u32):
    v93 = eq v8, u32 0
    jmpif v93 then: b25, else: b10
  b25():
    v161 = eq v8, u32 0
    constrain v8 == u32 0 '"Index out of bounds"'
    v162 = array_get [v3], index v8
    v163 = load v86
    inc_rc v163
    v164 = load v89
    inc_rc v164
    v165 = load v90
    v166 = load v91
    v167 = not v166
    constrain v166 == u1 0
    v168 = eq v165, u32 3
    jmpif v168 then: b27, else: b26
  b27():
    v173 = load v86
    inc_rc v173
    v174 = load v89
    inc_rc v174
    jmp b28(u32 0)
  b28(v11: u32):
    v175 = lt v11, u32 3
    jmpif v175 then: b31, else: b29
  b31():
    v183 = load v90
    v184 = lt v11, v183
    jmpif v184 then: b32, else: b33
  b32():
    v185 = load v86
    v186 = load v89
    v187 = array_get v186, index v11
    v188 = array_get v185, index v11
    v189 = add v187, v188
    v190 = array_set v186, index v11, value v189
    v191 = add v11, u32 1
    store v190 at v89
    jmp b33()
  b33():
    v192 = add v11, u32 1
    jmp b28(v192)
  b29():
    v176 = load v86
    v177 = load v89
    v178 = call poseidon2_permutation(v177, u32 4)
    inc_rc v178
    dec_rc v176
    dec_rc v178
    v179 = array_set v176, index u32 0, value v162
    store v179 at v86
    store v178 at v89
    store u32 1 at v90
    jmp b30()
  b30():
    v180 = load v86
    dec_rc v180
    v181 = load v89
    dec_rc v181
    v182 = add v8, u32 1
    jmp b9(v182)
  b26():
    v169 = load v86
    v170 = load v90
    v171 = array_set v169, index v170, value v162
    v172 = add v170, u32 1
    store v171 at v86
    store v172 at v90
    jmp b30()
  b10():
    v94 = load v86
    inc_rc v94
    v95 = load v89
    inc_rc v95
    v96 = load v91
    v97 = not v96
    constrain v96 == u1 0
    inc_rc v94
    inc_rc v95
    jmp b11(u32 0)
  b11(v9: u32):
    v99 = lt v9, u32 3
    jmpif v99 then: b22, else: b12
  b22():
    v151 = load v90
    v152 = lt v9, v151
    jmpif v152 then: b23, else: b24
  b23():
    v153 = load v86
    v154 = load v89
    v155 = array_get v154, index v9
    v156 = array_get v153, index v9
    v157 = add v155, v156
    v158 = array_set v154, index v9, value v157
    v159 = add v9, u32 1
    store v158 at v89
    jmp b24()
  b24():
    v160 = add v9, u32 1
    jmp b11(v160)
  b12():
    v100 = load v86
    v101 = load v89
    v104 = call poseidon2_permutation(v101, u32 4)
    inc_rc v104
    dec_rc v100
    dec_rc v104
    store v104 at v89
    store u1 1 at v91
    v106 = array_get v104, index u32 0
    dec_rc v100
    dec_rc v104
    v107 = truncate v106 to 32 bits, max_bit_size: 254
    v108 = cast v107 as u32
    v109 = load v0
    jmp b13(u32 0)
  b13(v10: u32):
    v110 = lt v10, v109
    jmpif v110 then: b14, else: b21
  b14():
    v111 = load v0
    v112 = load v1
    v113 = mul v10, v10
    v114 = add v10, v113
    v115 = div v114, u32 2
    v116 = add v108, v115
    v117 = mod v116, v111
    v118 = mul v117, u32 4
    v119 = lt v117, v111
    constrain v119 == u1 1 '"Index out of bounds"'
    v120 = array_get v112, index v118
    v121 = add v118, u32 1
    constrain v119 == u1 1 '"Index out of bounds"'
    v122 = array_get v112, index v121
    v123 = add v118, u32 2
    constrain v119 == u1 1 '"Index out of bounds"'
    v124 = array_get v112, index v123
    v125 = add v118, u32 3
    constrain v119 == u1 1 '"Index out of bounds"'
    v126 = array_get v112, index v125
    v127 = allocate
    v128 = allocate
    v129 = allocate
    v130 = allocate
    v131 = allocate
    store u1 0 at v131
    v132 = not v120
    v133 = or v126, v132
    jmpif v133 then: b17, else: b15
  b17():
    store u1 1 at v131
    v135 = load v2
    v136 = add v135, u32 1
    store v136 at v2
    jmp b18()
  b18():
    v137 = load v131
    jmpif v137 then: b20, else: b19
  b20():
    store u1 1 at v127
    store v3 at v128
    store v4 at v129
    store u1 0 at v130
    v139 = load v1
    v140 = load v2
    v141 = mul v117, u32 4
    v142 = array_set v139, index v141, value u1 1
    v143 = add v141, u32 1
    v144 = array_set v142, index v143, value v3
    v145 = add v143, u32 1
    v146 = array_set v144, index v145, value v4
    v147 = add v145, u32 1
    v148 = array_set v146, index v147, value u1 0
    v149 = add v147, u32 1
    store v148 at v1
    store v140 at v2
    jmp b21()
  b21():
    v150 = load v1
    dec_rc v150
    return 
  b19():
    v138 = add v10, u32 1
    jmp b13(v138)
  b15():
    v134 = eq v122, v3
    jmpif v134 then: b16, else: b18
  b16():
    store u1 1 at v131
    jmp b18()
}

After Constraint Folding:
brillig fn main f0 {
  b0(v0: [Field, Field; 6]):
    v2 = array_get v0, index u32 0
    v4 = array_get v0, index u32 1
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    v8 = allocate
    store u32 1 at v8
    inc_rc [u1 0, Field 0, Field 0, u1 0]
    v9 = allocate
    store [u1 0, Field 0, Field 0, u1 0] at v9
    v10 = allocate
    store u32 0 at v10
    call f1(v8, v9, v10, v2, v4)
    constrain u32 0 == u32 1 '"UHashMap after one insert should have a length of 1 element."'
    return 
}
brillig fn insert f1 {
  b0(v0: &mut u32, v1: &mut [u1, Field, Field, u1], v2: &mut u32, v3: Field, v4: Field):
    v12 = load v1
    inc_rc v12
    inc_rc v12
    v13 = load v0
    v14 = load v2
    v16 = add v14, u32 1
    v18 = div v13, u32 2
    v19 = lt v16, v18
    v20 = not v19
    jmpif v20 then: b1, else: b8
  b1():
    v21 = load v0
    v22 = mul v21, u32 2
    v23 = allocate
    store u32 0 at v23
    inc_rc []
    v26 = allocate
    store [] at v26
    jmp b2(u32 0)
  b2(v5: u32):
    v27 = lt v5, v22
    jmpif v27 then: b38, else: b3
  b38():
    v216 = load v23
    v217 = load v26
    v218, v219 = call slice_push_back(v216, v217, u1 0, Field 0, Field 0, u1 0)
    inc_rc v219
    store v218 at v23
    store v219 at v26
    v220 = add v5, u32 1
    jmp b2(v220)
  b3():
    v28 = load v23
    v29 = load v26
    inc_rc v29
    v30 = allocate
    store v28 at v30
    inc_rc v29
    v31 = allocate
    store v29 at v31
    v32 = allocate
    store u32 0 at v32
    v33 = load v0
    v34 = load v1
    v35 = load v2
    v36 = allocate
    store u32 0 at v36
    inc_rc []
    v38 = allocate
    store [] at v38
    inc_rc v34
    jmp b4(u32 0)
  b4(v6: u32):
    v39 = lt v6, v33
    jmpif v39 then: b35, else: b5
  b35():
    v199 = mul v6, u32 4
    v200 = lt v6, v33
    constrain v200 == u1 1 '"Index out of bounds"'
    v201 = array_get v34, index v199
    v202 = add v199, u32 1
    v203 = array_get v34, index v202
    v204 = add v199, u32 2
    v205 = array_get v34, index v204
    v206 = add v199, u32 3
    v207 = array_get v34, index v206
    v208 = not v207
    v209 = mul v208, v201
    jmpif v209 then: b36, else: b37
  b36():
    v210 = load v36
    v211 = load v38
    v213, v214 = call slice_push_back(v210, v211, v203, v205)
    inc_rc v214
    store v213 at v36
    store v214 at v38
    jmp b37()
  b37():
    v215 = add v6, u32 1
    jmp b4(v215)
  b5():
    inc_rc [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46]
    v67 = load v36
    v68 = load v38
    v69 = eq v67, v35
    constrain v67 == v35, data [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46], u32 0
    inc_rc v68
    jmp b6(u32 0)
  b6(v7: u32):
    v70 = lt v7, v67
    jmpif v70 then: b34, else: b7
  b34():
    v192 = mul v7, u32 2
    v193 = lt v7, v67
    constrain v193 == u1 1 '"Index out of bounds"'
    v194 = array_get v68, index v192
    v195 = add v192, u32 1
    v196 = array_get v68, index v195
    call f1(v30, v31, v32, v194, v196)
    v198 = add v7, u32 1
    jmp b6(v198)
  b7():
    v71 = load v30
    v72 = load v31
    v73 = load v32
    inc_rc v72
    store v71 at v0
    store v72 at v1
    store v73 at v2
    jmp b8()
  b8():
    v74 = load v1
    dec_rc v74
    inc_rc []
    v76 = allocate
    inc_rc []
    v77 = allocate
    inc_rc []
    inc_rc []
    inc_rc [v3]
    dec_rc [v3]
    dec_rc [v3]
    inc_rc [Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    inc_rc [Field 0, Field 0, Field 0]
    v82 = allocate
    inc_rc [Field 0, Field 0, Field 0, Field 0]
    v83 = allocate
    v84 = allocate
    v85 = allocate
    inc_rc [Field 0, Field 0, Field 0]
    v86 = allocate
    store [Field 0, Field 0, Field 0] at v86
    inc_rc [Field 0, Field 0, Field 0, Field 2⁶⁴]
    v89 = allocate
    store [Field 0, Field 0, Field 0, Field 2⁶⁴] at v89
    v90 = allocate
    store u32 0 at v90
    v91 = allocate
    store u1 0 at v91
    jmp b9(u32 0)
  b9(v8: u32):
    v93 = eq v8, u32 0
    jmpif v93 then: b25, else: b10
  b25():
    v161 = eq v8, u32 0
    constrain v8 == u32 0 '"Index out of bounds"'
    v162 = load v86
    inc_rc v162
    v163 = load v89
    inc_rc v163
    v164 = load v90
    v165 = load v91
    v166 = not v165
    constrain v165 == u1 0
    v167 = eq v164, u32 3
    jmpif v167 then: b27, else: b26
  b27():
    v172 = load v86
    inc_rc v172
    v173 = load v89
    inc_rc v173
    jmp b28(u32 0)
  b28(v11: u32):
    v174 = lt v11, u32 3
    jmpif v174 then: b31, else: b29
  b31():
    v182 = load v90
    v183 = lt v11, v182
    jmpif v183 then: b32, else: b33
  b32():
    v184 = load v86
    v185 = load v89
    v186 = array_get v185, index v11
    v187 = array_get v184, index v11
    v188 = add v186, v187
    v189 = array_set v185, index v11, value v188
    v190 = add v11, u32 1
    store v189 at v89
    jmp b33()
  b33():
    v191 = add v11, u32 1
    jmp b28(v191)
  b29():
    v175 = load v86
    v176 = load v89
    v177 = call poseidon2_permutation(v176, u32 4)
    inc_rc v177
    dec_rc v175
    dec_rc v177
    v178 = array_set v175, index u32 0, value v3
    store v178 at v86
    store v177 at v89
    store u32 1 at v90
    jmp b30()
  b30():
    v179 = load v86
    dec_rc v179
    v180 = load v89
    dec_rc v180
    v181 = add v8, u32 1
    jmp b9(v181)
  b26():
    v168 = load v86
    v169 = load v90
    v170 = array_set v168, index v169, value v3
    v171 = add v169, u32 1
    store v170 at v86
    store v171 at v90
    jmp b30()
  b10():
    v94 = load v86
    inc_rc v94
    v95 = load v89
    inc_rc v95
    v96 = load v91
    v97 = not v96
    constrain v96 == u1 0
    inc_rc v94
    inc_rc v95
    jmp b11(u32 0)
  b11(v9: u32):
    v99 = lt v9, u32 3
    jmpif v99 then: b22, else: b12
  b22():
    v151 = load v90
    v152 = lt v9, v151
    jmpif v152 then: b23, else: b24
  b23():
    v153 = load v86
    v154 = load v89
    v155 = array_get v154, index v9
    v156 = array_get v153, index v9
    v157 = add v155, v156
    v158 = array_set v154, index v9, value v157
    v159 = add v9, u32 1
    store v158 at v89
    jmp b24()
  b24():
    v160 = add v9, u32 1
    jmp b11(v160)
  b12():
    v100 = load v86
    v101 = load v89
    v104 = call poseidon2_permutation(v101, u32 4)
    inc_rc v104
    dec_rc v100
    dec_rc v104
    store v104 at v89
    store u1 1 at v91
    v106 = array_get v104, index u32 0
    dec_rc v100
    dec_rc v104
    v107 = truncate v106 to 32 bits, max_bit_size: 254
    v108 = cast v107 as u32
    v109 = load v0
    jmp b13(u32 0)
  b13(v10: u32):
    v110 = lt v10, v109
    jmpif v110 then: b14, else: b21
  b14():
    v111 = load v0
    v112 = load v1
    v113 = mul v10, v10
    v114 = add v10, v113
    v115 = div v114, u32 2
    v116 = add v108, v115
    v117 = mod v116, v111
    v118 = mul v117, u32 4
    v119 = lt v117, v111
    constrain v119 == u1 1 '"Index out of bounds"'
    v120 = array_get v112, index v118
    v121 = add v118, u32 1
    v122 = array_get v112, index v121
    v123 = add v118, u32 2
    v124 = array_get v112, index v123
    v125 = add v118, u32 3
    v126 = array_get v112, index v125
    v127 = allocate
    v128 = allocate
    v129 = allocate
    v130 = allocate
    v131 = allocate
    store u1 0 at v131
    v132 = not v120
    v133 = or v126, v132
    jmpif v133 then: b17, else: b15
  b17():
    store u1 1 at v131
    v135 = load v2
    v136 = add v135, u32 1
    store v136 at v2
    jmp b18()
  b18():
    v137 = load v131
    jmpif v137 then: b20, else: b19
  b20():
    store u1 1 at v127
    store v3 at v128
    store v4 at v129
    store u1 0 at v130
    v139 = load v1
    v140 = load v2
    v141 = mul v117, u32 4
    v142 = array_set v139, index v141, value u1 1
    v143 = add v141, u32 1
    v144 = array_set v142, index v143, value v3
    v145 = add v143, u32 1
    v146 = array_set v144, index v145, value v4
    v147 = add v145, u32 1
    v148 = array_set v146, index v147, value u1 0
    v149 = add v147, u32 1
    store v148 at v1
    store v140 at v2
    jmp b21()
  b21():
    v150 = load v1
    dec_rc v150
    return 
  b19():
    v138 = add v10, u32 1
    jmp b13(v138)
  b15():
    v134 = eq v122, v3
    jmpif v134 then: b16, else: b18
  b16():
    store u1 1 at v131
    jmp b18()
}

After Dead Instruction Elimination:
brillig fn main f0 {
  b0(v0: [Field, Field; 6]):
    v2 = array_get v0, index u32 0
    v4 = array_get v0, index u32 1
    v5 = allocate
    store u32 1 at v5
    v6 = allocate
    store [u1 0, Field 0, Field 0, u1 0] at v6
    v10 = allocate
    store u32 0 at v10
    call f1(v5, v6, v10, v2, v4)
    constrain u32 0 == u32 1 '"UHashMap after one insert should have a length of 1 element."'
    return 
}
brillig fn insert f1 {
  b0(v0: &mut u32, v1: &mut [u1, Field, Field, u1], v2: &mut u32, v3: Field, v4: Field):
    v12 = load v0
    v13 = load v2
    v15 = add v13, u32 1
    v17 = div v12, u32 2
    v18 = lt v15, v17
    v19 = not v18
    jmpif v19 then: b1, else: b8
  b1():
    v20 = load v0
    v21 = mul v20, u32 2
    v22 = allocate
    store u32 0 at v22
    v24 = allocate
    store [] at v24
    jmp b2(u32 0)
  b2(v5: u32):
    v26 = lt v5, v21
    jmpif v26 then: b38, else: b3
  b38():
    v186 = load v22
    v187 = load v24
    v188, v189 = call slice_push_back(v186, v187, u1 0, Field 0, Field 0, u1 0)
    inc_rc v189
    store v188 at v22
    store v189 at v24
    v190 = add v5, u32 1
    jmp b2(v190)
  b3():
    v27 = load v22
    v28 = load v24
    inc_rc v28
    v29 = allocate
    store v27 at v29
    inc_rc v28
    v30 = allocate
    store v28 at v30
    v31 = allocate
    store u32 0 at v31
    v32 = load v0
    v33 = load v1
    v34 = load v2
    v35 = allocate
    store u32 0 at v35
    v36 = allocate
    store [] at v36
    inc_rc v33
    jmp b4(u32 0)
  b4(v6: u32):
    v38 = lt v6, v32
    jmpif v38 then: b35, else: b5
  b35():
    v169 = mul v6, u32 4
    v170 = lt v6, v32
    constrain v170 == u1 1 '"Index out of bounds"'
    v171 = array_get v33, index v169
    v172 = add v169, u32 1
    v173 = array_get v33, index v172
    v174 = add v169, u32 2
    v175 = array_get v33, index v174
    v176 = add v169, u32 3
    v177 = array_get v33, index v176
    v178 = not v177
    v179 = mul v178, v171
    jmpif v179 then: b36, else: b37
  b36():
    v180 = load v35
    v181 = load v36
    v183, v184 = call slice_push_back(v180, v181, v173, v175)
    inc_rc v184
    store v183 at v35
    store v184 at v36
    jmp b37()
  b37():
    v185 = add v6, u32 1
    jmp b4(v185)
  b5():
    v39 = load v35
    v40 = load v36
    constrain v39 == v34, data [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46], u32 0
    inc_rc v40
    jmp b6(u32 0)
  b6(v7: u32):
    v68 = lt v7, v39
    jmpif v68 then: b34, else: b7
  b34():
    v162 = mul v7, u32 2
    v163 = lt v7, v39
    constrain v163 == u1 1 '"Index out of bounds"'
    v164 = array_get v40, index v162
    v165 = add v162, u32 1
    v166 = array_get v40, index v165
    call f1(v29, v30, v31, v164, v166)
    v168 = add v7, u32 1
    jmp b6(v168)
  b7():
    v69 = load v29
    v70 = load v30
    v71 = load v31
    inc_rc v70
    store v69 at v0
    store v70 at v1
    store v71 at v2
    jmp b8()
  b8():
    v72 = allocate
    store [Field 0, Field 0, Field 0] at v72
    v75 = allocate
    store [Field 0, Field 0, Field 0, Field 2⁶⁴] at v75
    v78 = allocate
    store u32 0 at v78
    v79 = allocate
    store u1 0 at v79
    jmp b9(u32 0)
  b9(v8: u32):
    v81 = eq v8, u32 0
    jmpif v81 then: b25, else: b10
  b25():
    constrain v8 == u32 0 '"Index out of bounds"'
    v140 = load v78
    v141 = load v79
    constrain v141 == u1 0
    v142 = eq v140, u32 3
    jmpif v142 then: b27, else: b26
  b27():
    jmp b28(u32 0)
  b28(v11: u32):
    v147 = lt v11, u32 3
    jmpif v147 then: b31, else: b29
  b31():
    v153 = load v78
    v154 = lt v11, v153
    jmpif v154 then: b32, else: b33
  b32():
    v155 = load v72
    v156 = load v75
    v157 = array_get v156, index v11
    v158 = array_get v155, index v11
    v159 = add v157, v158
    v160 = array_set v156, index v11, value v159
    store v160 at v75
    jmp b33()
  b33():
    v161 = add v11, u32 1
    jmp b28(v161)
  b29():
    v148 = load v72
    v149 = load v75
    v150 = call poseidon2_permutation(v149, u32 4)
    inc_rc v150
    dec_rc v148
    dec_rc v150
    v151 = array_set v148, index u32 0, value v3
    store v151 at v72
    store v150 at v75
    store u32 1 at v78
    jmp b30()
  b30():
    v152 = add v8, u32 1
    jmp b9(v152)
  b26():
    v143 = load v72
    v144 = load v78
    v145 = array_set v143, index v144, value v3
    v146 = add v144, u32 1
    store v145 at v72
    store v146 at v78
    jmp b30()
  b10():
    v82 = load v79
    constrain v82 == u1 0
    jmp b11(u32 0)
  b11(v9: u32):
    v84 = lt v9, u32 3
    jmpif v84 then: b22, else: b12
  b22():
    v131 = load v78
    v132 = lt v9, v131
    jmpif v132 then: b23, else: b24
  b23():
    v133 = load v72
    v134 = load v75
    v135 = array_get v134, index v9
    v136 = array_get v133, index v9
    v137 = add v135, v136
    v138 = array_set v134, index v9, value v137
    store v138 at v75
    jmp b24()
  b24():
    v139 = add v9, u32 1
    jmp b11(v139)
  b12():
    v85 = load v75
    v88 = call poseidon2_permutation(v85, u32 4)
    inc_rc v88
    dec_rc v88
    store v88 at v75
    store u1 1 at v79
    v90 = array_get v88, index u32 0
    dec_rc v88
    v91 = truncate v90 to 32 bits, max_bit_size: 254
    v92 = cast v91 as u32
    v93 = load v0
    jmp b13(u32 0)
  b13(v10: u32):
    v94 = lt v10, v93
    jmpif v94 then: b14, else: b21
  b14():
    v95 = load v0
    v96 = load v1
    v97 = mul v10, v10
    v98 = add v10, v97
    v99 = div v98, u32 2
    v100 = add v92, v99
    v101 = mod v100, v95
    v102 = mul v101, u32 4
    v103 = lt v101, v95
    constrain v103 == u1 1 '"Index out of bounds"'
    v104 = array_get v96, index v102
    v105 = add v102, u32 1
    v106 = array_get v96, index v105
    v107 = add v102, u32 3
    v108 = array_get v96, index v107
    v109 = allocate
    v110 = allocate
    v111 = allocate
    v112 = allocate
    v113 = allocate
    store u1 0 at v113
    v114 = not v104
    v115 = or v108, v114
    jmpif v115 then: b17, else: b15
  b17():
    store u1 1 at v113
    v117 = load v2
    v118 = add v117, u32 1
    store v118 at v2
    jmp b18()
  b18():
    v119 = load v113
    jmpif v119 then: b20, else: b19
  b20():
    store u1 1 at v109
    store v3 at v110
    store v4 at v111
    store u1 0 at v112
    v121 = load v1
    v122 = load v2
    v123 = mul v101, u32 4
    v124 = array_set v121, index v123, value u1 1
    v125 = add v123, u32 1
    v126 = array_set v124, index v125, value v3
    v127 = add v125, u32 1
    v128 = array_set v126, index v127, value v4
    v129 = add v127, u32 1
    v130 = array_set v128, index v129, value u1 0
    store v130 at v1
    store v122 at v2
    jmp b21()
  b21():
    return 
  b19():
    v120 = add v10, u32 1
    jmp b13(v120)
  b15():
    v116 = eq v106, v3
    jmpif v116 then: b16, else: b18
  b16():
    store u1 1 at v113
    jmp b18()
}

After Array Set Optimizations:
brillig fn main f0 {
  b0(v0: [Field, Field; 6]):
    v2 = array_get v0, index u32 0
    v4 = array_get v0, index u32 1
    v5 = allocate
    store u32 1 at v5
    v6 = allocate
    store [u1 0, Field 0, Field 0, u1 0] at v6
    v10 = allocate
    store u32 0 at v10
    call f1(v5, v6, v10, v2, v4)
    constrain u32 0 == u32 1 '"UHashMap after one insert should have a length of 1 element."'
    return 
}
brillig fn insert f1 {
  b0(v0: &mut u32, v1: &mut [u1, Field, Field, u1], v2: &mut u32, v3: Field, v4: Field):
    v12 = load v0
    v13 = load v2
    v15 = add v13, u32 1
    v17 = div v12, u32 2
    v18 = lt v15, v17
    v19 = not v18
    jmpif v19 then: b1, else: b8
  b1():
    v20 = load v0
    v21 = mul v20, u32 2
    v22 = allocate
    store u32 0 at v22
    v24 = allocate
    store [] at v24
    jmp b2(u32 0)
  b2(v5: u32):
    v26 = lt v5, v21
    jmpif v26 then: b38, else: b3
  b38():
    v186 = load v22
    v187 = load v24
    v188, v189 = call slice_push_back(v186, v187, u1 0, Field 0, Field 0, u1 0)
    inc_rc v189
    store v188 at v22
    store v189 at v24
    v190 = add v5, u32 1
    jmp b2(v190)
  b3():
    v27 = load v22
    v28 = load v24
    inc_rc v28
    v29 = allocate
    store v27 at v29
    inc_rc v28
    v30 = allocate
    store v28 at v30
    v31 = allocate
    store u32 0 at v31
    v32 = load v0
    v33 = load v1
    v34 = load v2
    v35 = allocate
    store u32 0 at v35
    v36 = allocate
    store [] at v36
    inc_rc v33
    jmp b4(u32 0)
  b4(v6: u32):
    v38 = lt v6, v32
    jmpif v38 then: b35, else: b5
  b35():
    v169 = mul v6, u32 4
    v170 = lt v6, v32
    constrain v170 == u1 1 '"Index out of bounds"'
    v171 = array_get v33, index v169
    v172 = add v169, u32 1
    v173 = array_get v33, index v172
    v174 = add v169, u32 2
    v175 = array_get v33, index v174
    v176 = add v169, u32 3
    v177 = array_get v33, index v176
    v178 = not v177
    v179 = mul v178, v171
    jmpif v179 then: b36, else: b37
  b36():
    v180 = load v35
    v181 = load v36
    v183, v184 = call slice_push_back(v180, v181, v173, v175)
    inc_rc v184
    store v183 at v35
    store v184 at v36
    jmp b37()
  b37():
    v185 = add v6, u32 1
    jmp b4(v185)
  b5():
    v39 = load v35
    v40 = load v36
    constrain v39 == v34, data [u8 65, u8 109, u8 111, u8 117, u8 110, u8 116, u8 2⁵, u8 111, u8 102, u8 2⁵, u8 118, u8 97, u8 108, u8 105, u8 100, u8 2⁵, u8 101, u8 108, u8 101, u8 109, u8 101, u8 110, u8 116, u8 115, u8 2⁵, u8 115, u8 104, u8 111, u8 117, u8 108, u8 100, u8 2⁵, u8 104, u8 97, u8 118, u8 101, u8 2⁵, u8 98, u8 101, u8 101, u8 110, u8 2⁵, u8 123, u8 115, u8 101, u8 108, u8 102, u8 46, u8 95, u8 108, u8 101, u8 110, u8 125, u8 2⁵, u8 116, u8 105, u8 109, u8 101, u8 115, u8 44, u8 2⁵, u8 98, u8 117, u8 116, u8 2⁵, u8 103, u8 111, u8 116, u8 2⁵, u8 123, u8 101, u8 110, u8 116, u8 114, u8 105, u8 101, u8 115, u8 46, u8 108, u8 101, u8 110, u8 40, u8 41, u8 125, u8 46], u32 0
    inc_rc v40
    jmp b6(u32 0)
  b6(v7: u32):
    v68 = lt v7, v39
    jmpif v68 then: b34, else: b7
  b34():
    v162 = mul v7, u32 2
    v163 = lt v7, v39
    constrain v163 == u1 1 '"Index out of bounds"'
    v164 = array_get v40, index v162
    v165 = add v162, u32 1
    v166 = array_get v40, index v165
    call f1(v29, v30, v31, v164, v166)
    v168 = add v7, u32 1
    jmp b6(v168)
  b7():
    v69 = load v29
    v70 = load v30
    v71 = load v31
    inc_rc v70
    store v69 at v0
    store v70 at v1
    store v71 at v2
    jmp b8()
  b8():
    v72 = allocate
    store [Field 0, Field 0, Field 0] at v72
    v75 = allocate
    store [Field 0, Field 0, Field 0, Field 2⁶⁴] at v75
    v78 = allocate
    store u32 0 at v78
    v79 = allocate
    store u1 0 at v79
    jmp b9(u32 0)
  b9(v8: u32):
    v81 = eq v8, u32 0
    jmpif v81 then: b25, else: b10
  b25():
    constrain v8 == u32 0 '"Index out of bounds"'
    v140 = load v78
    v141 = load v79
    constrain v141 == u1 0
    v142 = eq v140, u32 3
    jmpif v142 then: b27, else: b26
  b27():
    jmp b28(u32 0)
  b28(v11: u32):
    v147 = lt v11, u32 3
    jmpif v147 then: b31, else: b29
  b31():
    v153 = load v78
    v154 = lt v11, v153
    jmpif v154 then: b32, else: b33
  b32():
    v155 = load v72
    v156 = load v75
    v157 = array_get v156, index v11
    v158 = array_get v155, index v11
    v159 = add v157, v158
    v160 = array_set v156, index v11, value v159
    store v160 at v75
    jmp b33()
  b33():
    v161 = add v11, u32 1
    jmp b28(v161)
  b29():
    v148 = load v72
    v149 = load v75
    v150 = call poseidon2_permutation(v149, u32 4)
    inc_rc v150
    dec_rc v148
    dec_rc v150
    v151 = array_set v148, index u32 0, value v3
    store v151 at v72
    store v150 at v75
    store u32 1 at v78
    jmp b30()
  b30():
    v152 = add v8, u32 1
    jmp b9(v152)
  b26():
    v143 = load v72
    v144 = load v78
    v145 = array_set v143, index v144, value v3
    v146 = add v144, u32 1
    store v145 at v72
    store v146 at v78
    jmp b30()
  b10():
    v82 = load v79
    constrain v82 == u1 0
    jmp b11(u32 0)
  b11(v9: u32):
    v84 = lt v9, u32 3
    jmpif v84 then: b22, else: b12
  b22():
    v131 = load v78
    v132 = lt v9, v131
    jmpif v132 then: b23, else: b24
  b23():
    v133 = load v72
    v134 = load v75
    v135 = array_get v134, index v9
    v136 = array_get v133, index v9
    v137 = add v135, v136
    v138 = array_set v134, index v9, value v137
    store v138 at v75
    jmp b24()
  b24():
    v139 = add v9, u32 1
    jmp b11(v139)
  b12():
    v85 = load v75
    v88 = call poseidon2_permutation(v85, u32 4)
    inc_rc v88
    dec_rc v88
    store v88 at v75
    store u1 1 at v79
    v90 = array_get v88, index u32 0
    dec_rc v88
    v91 = truncate v90 to 32 bits, max_bit_size: 254
    v92 = cast v91 as u32
    v93 = load v0
    jmp b13(u32 0)
  b13(v10: u32):
    v94 = lt v10, v93
    jmpif v94 then: b14, else: b21
  b14():
    v95 = load v0
    v96 = load v1
    v97 = mul v10, v10
    v98 = add v10, v97
    v99 = div v98, u32 2
    v100 = add v92, v99
    v101 = mod v100, v95
    v102 = mul v101, u32 4
    v103 = lt v101, v95
    constrain v103 == u1 1 '"Index out of bounds"'
    v104 = array_get v96, index v102
    v105 = add v102, u32 1
    v106 = array_get v96, index v105
    v107 = add v102, u32 3
    v108 = array_get v96, index v107
    v109 = allocate
    v110 = allocate
    v111 = allocate
    v112 = allocate
    v113 = allocate
    store u1 0 at v113
    v114 = not v104
    v115 = or v108, v114
    jmpif v115 then: b17, else: b15
  b17():
    store u1 1 at v113
    v117 = load v2
    v118 = add v117, u32 1
    store v118 at v2
    jmp b18()
  b18():
    v119 = load v113
    jmpif v119 then: b20, else: b19
  b20():
    store u1 1 at v109
    store v3 at v110
    store v4 at v111
    store u1 0 at v112
    v121 = load v1
    v122 = load v2
    v123 = mul v101, u32 4
    v124 = array_set v121, index v123, value u1 1
    v125 = add v123, u32 1
    v126 = array_set v124, index v125, value v3
    v127 = add v125, u32 1
    v128 = array_set v126, index v127, value v4
    v129 = add v127, u32 1
    v130 = array_set v128, index v129, value u1 0
    store v130 at v1
    store v122 at v2
    jmp b21()
  b21():
    return 
  b19():
    v120 = add v10, u32 1
    jmp b13(v120)
  b15():
    v116 = eq v106, v3
    jmpif v116 then: b16, else: b18
  b16():
    store u1 1 at v113
    jmp b18()
}

